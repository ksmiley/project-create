package edu.uky.comm.controls{	import flash.display.Sprite;	import flash.events.Event;		import edu.uky.comm.controls.AccordianPane;		public class AccordianGroup extends Sprite	{				private var _multiOpen:Boolean;		private var _panes:Array;				private var _awaitingRender:Boolean = false;				public function AccordianGroup():void		{			_multiOpen = true;			_panes = new Array();		}				public function get multiOpen():Boolean		{			return _multiOpen;		}				public function set multiOpen(value:Boolean)		{			if (value != _multiOpen)			{				_multiOpen = value;				// when multiOpen is toggled from on to off, it's possible more than				// one pane is currently open. if so, close all but the first				if (!_multiOpen)				{					// track whether an open one has been found. after one is found, the					// rest need to be closed					var openFound:Boolean = false;					for each (var pane:AccordianPane in _panes)					{						if (pane.expanded)						{							// if an open pane has already been seen, this one needs to close							if (openFound)							{								pane.expanded = false;							}							else							{								openFound = true;							}						}					}				}			}		}				override public function set width(value:Number):void		{			if (value > 0 && value != width)			{				for each (var pane:AccordianPane in _panes)				{					pane.width = value;				}				_requestReposition();			}		}				public function refresh():void		{			_requestReposition();		}				public function addPane(pane:AccordianPane):void		{			if (pane != null)			{				// see if the pane is already in the list. if so, move it to the end				var curPos:int = _findPanePos(pane);				if (curPos >= 0)				{					_panes.splice(curPos, 1);				}				pane.addEventListener(Event.CHANGE, _paneChangeHandler, false, 0, true);				_panes.push(pane);				addChild(pane);				_requestReposition();				dispatchEvent(new Event(Event.CHANGE));			}		}				public function removePane(pane:AccordianPane):void		{			if (pane != null)			{				// find the pane in the list. for obvious reasons, only try to				// remove it if it's found.				var curPos:int = _findPanePos(pane);				if (curPos >= 0)				{					_panes[curPos].removeEventListener(Event.CHANGE, _paneChangeHandler);					removeChild(_panes[curPos]);					_panes.splice(curPos, 1);					_requestReposition();					dispatchEvent(new Event(Event.CHANGE));				}			}		}				public function removeAllPanes():void		{			for each (var pane:AccordianPane in _panes)			{				pane.removeEventListener(Event.CHANGE, _paneChangeHandler);				removeChild(pane);			}			_panes.splice(0);			_requestReposition();			dispatchEvent(new Event(Event.CHANGE));		}				public function getPanes():Array		{			return _panes;		}				public function getPaneAt(index:int):AccordianPane		{			return (index >= 0 && index < _panes.length ? _panes[index] : null);		}				public function getPaneIndex(pane:AccordianPane):int		{			return (pane != null ? _findPanePos(pane) : -1);		}				private function _positionPanes():void		{			var curY:Number = 0;			for each (var pane:AccordianPane in _panes)			{				pane.x = 0;				pane.y = curY;				curY += pane.height;			}		}				private function _findPanePos(pane:AccordianPane):int		{			var match:Boolean = false;			var i:int;			for (i = 0; i < _panes.length; i++)			{				if (pane === _panes[i])				{					match = true;					break;				}			}			return (match ? i : -1);		}				// if this is the first time a tab has been expanded, it won't yet be fully rendered, 		// which means the height property isn't reliable. to work around this, delay the 		// reposition until just before the screen is updated. the RENDER listener is added here,		// unless the stage isn't available, in which case wait to be added, then register		// for the render event		private function _requestReposition():void		{			if (_awaitingRender)  return;						_awaitingRender = true;			if (stage != null)			{				stage.addEventListener(Event.RENDER, _renderHandler, false, 0, true);				stage.invalidate();			}			else			{				addEventListener(Event.ADDED_TO_STAGE, _addedToStageHandler, false, 0, true);			}		}				// if the stage wasn't available when _requestReposition was called before, it is now,		// so stop listening for ADDED_TO_STAGE and request a RENDER event		private function _addedToStageHandler(e:Event):void		{			removeEventListener(Event.ADDED_TO_STAGE, _addedToStageHandler);			stage.addEventListener(Event.RENDER, _renderHandler, false, 0, true);			stage.invalidate();		}				// screen is about to be updated, so reposition the panes		private function _renderHandler(e:Event):void		{			_awaitingRender = false;			// screen is about to refresh and all the buttons are added, so put them in place.			// only need to do this once, so get rid of the RENDER event too			if (stage != null)  stage.removeEventListener(Event.RENDER, _renderHandler);			_positionPanes();		}				// one of the panes has opened or closed, so update the others to be in the right place.		private function _paneChangeHandler(e:Event):void		{			var changedPane:AccordianPane = e.target as AccordianPane;			if (!(changedPane is AccordianPane))  return;			// if only one pane is allowed to be open at a time and this one just opened,			// then make sure all the others are closed			if (!_multiOpen && changedPane.expanded)			{				for each (var pane:AccordianPane in _panes)				{					if (pane !== changedPane && pane.expanded)					{						// keep the handler from basically triggering itself again. there's no						// point in running _paneChangeHandler a second time, since the repositioning						// will already be done and the group event dispatched						pane.removeEventListener(Event.CHANGE, _paneChangeHandler);						pane.expanded = false;						pane.addEventListener(Event.CHANGE, _paneChangeHandler, false, 0, true);					}				}			}			// since the panes changed, they need to be rearranged before the screen refreshes			_requestReposition();			// let AccordianGroup listeners know something changed			dispatchEvent(new Event(Event.CHANGE));		}	}}