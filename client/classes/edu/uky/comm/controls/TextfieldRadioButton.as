package edu.uky.comm.controls{	import flash.text.TextFieldType;	import flash.text.TextFormat;	import flash.events.Event;	import flash.events.FocusEvent;	import flash.events.MouseEvent;	import flash.events.KeyboardEvent;	import flash.display.DisplayObject;	import flash.display.InteractiveObject;	import flash.ui.Keyboard;		import fl.core.UIComponent;	import fl.core.InvalidationType;	import fl.events.ComponentEvent;	import fl.controls.ButtonLabelPlacement;	import fl.controls.RadioButtonGroup;		import edu.uky.comm.controls.MultilineRadioButton;		[Style(name="emptyTextFormat", type="flash.text.TextFormat")]	public class TextfieldRadioButton extends MultilineRadioButton	{		protected var _labelFormat:TextFormat;		protected var _showDefault:Boolean;				private var _calledKeySuper:Boolean = false;				public function TextfieldRadioButton()		{			super();			_showDefault = true;			mouseChildren = true;  // turn this back on so the text field can be clicked		}				public function get userText():String		{			return (_showDefault ? "" : textField.text);		}				public function set userText(value:String):void		{			if (_showDefault || value != textField.text)			{				if (value.length > 0)				{					// act as if user had entered the text, so switch off the default, put the text in,					// and send out a LABEL_CHANGE event					_showDefault = false;					textField.text = value;					invalidate(InvalidationType.STYLES);					dispatchEvent(new ComponentEvent(ComponentEvent.LABEL_CHANGE));				}				else				{					// text has been cleared out. if the textfield doesn't have focus, switch the					// default back on. however, if it does have focus, leave the default off but					// send out a LABEL_CHANGE, as if the user cleared the field out					if (stage != null && isOurFocus(stage.focus))					{						textField.text = "";						dispatchEvent(new ComponentEvent(ComponentEvent.LABEL_CHANGE));					}					else					{						_showDefault = true;						label = _label;   // will handle resetting textfield and invalidating style					}				}			}		}				override public function set label(value:String):void		{			// see if the defaultLabel text is currently in the textField. only change			// what's being displayed if it's not user-entered			if (_showDefault)			{				textField.text = (value == null) ? "" : value;			}			_label = value;						// these are usually called by LabelButton, but can't use super here because			// the original setter will overwrite any user-entered value. it also sends			// a LABEL_CHANGE event, which isn't desired here			invalidate(InvalidationType.SIZE);			invalidate(InvalidationType.STYLES);		}				// when the group changes, move the early selection handler to the new group.		// the early handler registers with an extremely high priority so it can run		// first whenever the selection changes, and is necessary for when the user		// uses the keyboard arrow keys to change selection to the TextfieldRadioButton,		// because this event is fired before the focus is changed, so listeners for the		// group event chang will find the default label text still in the textField		override public function set groupName(group:String):void {			if (_group != null)			{				_group.removeEventListener(Event.CHANGE, _handleSelectionChangeEarly);			}			super.groupName = group;			if (_group != null)			{				_group.addEventListener(Event.CHANGE, _handleSelectionChangeEarly, false, int.MAX_VALUE, true);			}		}				override protected function configUI():void		{			super.configUI();			// switch the textField over to accept user input			textField.type = TextFieldType.INPUT;			textField.selectable = true;			textField.background = true;			textField.backgroundColor = 0xFFFFFFFF;			textField.border = true;			textField.borderColor = 0xFF000000;						// focus handlers place the default message into the empty textfield and clear			// it out when the user clicks in			addEventListener(FocusEvent.FOCUS_IN, _focusInHandler);			addEventListener(FocusEvent.FOCUS_OUT, _focusOutHandler);		}				override protected function drawLayout():void		{			super.drawLayout();			var placement:String = (icon == null && mode == "center") ? ButtonLabelPlacement.TOP : _labelPlacement;			if (placement == ButtonLabelPlacement.LEFT || placement == ButtonLabelPlacement.RIGHT)			{				textField.height = height;				// update these to make the focus rectangle display correctly				var txtPad:Number = Number(getStyleValue("textPadding"));				background.width = textField.x + textField.width + txtPad;				background.height = Math.max(textField.height, icon.height)+txtPad*2;			}		}				// override this to add a third type of text formatting, for when the default label is displayed. the code		// is nearly the same as what's in LabelButton, except adapted for "emptyTextFormat". if anything else is		// displayed, or the button is disabled, control is passed straight to the super object		override protected function drawTextFormat():void		{			if (enabled && _showDefault)			{				var uiStyles:Object = UIComponent.getStyleDefinition();				var defaultTF:TextFormat = uiStyles.defaultTextFormat as TextFormat;				textField.setTextFormat(defaultTF);								var tf:TextFormat = getStyleValue("emptyTextFormat") as TextFormat;				if (tf != null)				{					textField.setTextFormat(tf);				}				else				{					tf = defaultTF;				}				textField.defaultTextFormat = tf;				setEmbedFont();			}			else			{				super.drawTextFormat();			}		}				override protected function drawIcon():void		{			super.drawIcon();			// because mouseChildren was turned on for the textField, the icon will also			// receive mouse events, so explicitly turn it off here. while icon is declared			// as a DisplayObject (which don't take mouse events anyway), it will usually			// be loaded with a Sprite or MovieClip, so first check if it's interactive,			// then cast it so the property can be turned off			if (icon is InteractiveObject)			{				var tmpIcon:InteractiveObject = icon as InteractiveObject;				tmpIcon.mouseEnabled = false;			}		}				override public function setFocus():void		{			// when focus comes to the radio button, place it in the textfield for typing			if (stage)			{				stage.focus = textField;			}		}				override protected function isOurFocus(target:DisplayObject):Boolean {			// the component still has focus even if the focus is technically in the			// textfield, so acknowledge either one			return (target == textField || target == this);		}				// override the keyDownHandler because the textField has precedence. the standard handler		// works with the space and arrow keys, which are used to move between radio buttons and		// to make a selection. the textField needs these keys to be usable, but this RadioButton		// should play nice with the others, so this will pass control up the inheritance chain		// under these circumstances:		// (1) the user is holding down ctrl/alt/option/command when pressing the arrow keys		// (2) the user presses up while in the first line of the textfield or down while on the 		//     last line UNLESS the user is also holding down shift (so as to not interfere with		//     text selection)		override protected function keyDownHandler(event:KeyboardEvent):void		{			_calledKeySuper = false;			// when the caret is at the very end, it's larger than the last character index, 			// which confuses getLineIndexOfChar()			var curChar:int = (textField.caretIndex == textField.length) ? textField.caretIndex - 1 : textField.caretIndex;			var curLine:int = (textField.length > 0) ? textField.getLineIndexOfChar(curChar) : 0;			if ((event.ctrlKey && event.keyCode != Keyboard.SPACE) ||				(!event.shiftKey && (					(event.keyCode == Keyboard.DOWN && curLine == textField.numLines-1) || 					(event.keyCode == Keyboard.UP && curLine == 0)				)))			{				super.keyDownHandler(event);				_calledKeySuper = true;  // so keyUpHandler knows whether to call super			}		}				override protected function keyUpHandler(event:KeyboardEvent):void		{			// only call the parent keyUpHandler if the parent keyDownHandler was called			if (_calledKeySuper)			{				super.keyUpHandler(event);			}		}		private function _focusInHandler(e:FocusEvent):void		{			// when focus enters the text field, check to see if the default label			// is being displayed. if so, clear it out and give the user a blank slate			//stage.focus = textField;			if (String(textField.text) == _label)			{				textField.replaceText(0, textField.length, "");				_showDefault = false;				invalidate(InvalidationType.STYLES);			}			// add a handler so the TextfieldRadioButton can dispatch a LABEL_CHANGE whenever			// the user changes the textField			textField.addEventListener(Event.CHANGE, _textfieldChangeHandler);		}				private function _focusOutHandler(e:FocusEvent):void		{			// remove the change handler so that resetting the default label doesn't trigger			// a LABEL_CHANGE			textField.removeEventListener(Event.CHANGE, _textfieldChangeHandler);			// when focus leaves the text field, see if the field is empty. if so,			// re-display the default label (which is probably something like "Enter some text"			if (textField.text == "")			{				textField.text = _label;				_showDefault = true;				invalidate(InvalidationType.STYLES);			}		}				// when the user types something into the textfield, fire off a LABEL_CHANGE event. 		// this way code using the component doesn't have to deal with getting an event from the		// text field every time the default label is added or cleared		private function _textfieldChangeHandler(e:Event):void		{			// if the user used ctrl-down or ctrl-up to get to the textfield without selecting the			// radio button, then started typing, assume they want to select the radio button			if (!selected)  setThis();			dispatchEvent(new ComponentEvent(ComponentEvent.LABEL_CHANGE));		}				// preempt the other RadioButtonGroup change handlers so that if the user uses the		// keyboard to move selection to the TextfieldRadioButton, the textfield will be empty		// instead of having the default label. the focus in handler takes care of this for		// the mouse, but because the RadioButton keyDownHandler changes the group selection		// before it changes the focus, other code could look at the textField.text value		// before _focusInHandler is ever called		private function _handleSelectionChangeEarly(e:Event):void		{			if (_group.selection == this && String(textField.text) == _label)			{				textField.replaceText(0, textField.length, "");				_showDefault = false;				invalidate(InvalidationType.STYLES);			}		}				// setThis() is copied directly out of RadioButton, but since it's declared private,		// TextfieldRadioButton can't call it		private function setThis():void {			var g:RadioButtonGroup = _group;			if(g != null) {				if (g.selection != this) {					g.selection = this;				}			} else {				super.selected = true;			}		}	}}