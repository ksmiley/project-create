package edu.uky.comm.rcap{	import flash.display.Sprite;	import flash.display.Shape;	import flash.events.Event;	import flash.utils.Dictionary;		import fl.containers.ScrollPane;	import fl.controls.ScrollPolicy;	import fl.controls.ComboBox;	import fl.controls.RadioButtonGroup;	import fl.events.ComponentEvent;		import edu.uky.comm.controls.AccordianPane;	import edu.uky.comm.controls.AccordianGroup;	import edu.uky.comm.rcap.PosterTemplateSet;	import edu.uky.comm.rcap.PosterTemplate;	import edu.uky.comm.rcap.PosterTextArea;	import edu.uky.comm.rcap.MessageRadioCluster;	import edu.uky.comm.rcap.Message;	import edu.uky.comm.rcap.MessageSource;	import edu.uky.comm.rcap.MessageChangeEvent;	import edu.uky.comm.rcap.CustomCellRenderer;		public class InputPanel extends Sprite	{		private static const PAPER_PROMPT:String = "Select paper size…";		private static const MESSAGE_PROMPT:String = "Enter custom text…";		private static const COMBO_SPACING:Number = 10;		private static const SCROLLER_GUTTER:Number = 5;		private static const EXPAND_ICON:Class = AccordianExpand;		private static const CONTRACT_ICON:Class = AccordianContract;				// custom events. first is dispatched when the user changes the poster size,		// second is dispatched when the user changes one of the text areas, either		// by typing or by clicking a radio button		public static const SIZE_CHANGE:String = "rcapSizeChange";		public static const TEXT_CHANGE:String = "rcapTextChange";				var _sizeCombo:ComboBox;		var _scroller:ScrollPane;		var _group:AccordianGroup;		var _panes:Array;		var _clusters:Array;		var _clusterId:Array;		var _textFormats:Object;		var _contentWidth:Number;		var _accordianState:Dictionary;				var _curSet:PosterTemplateSet;		//var _messages:Array;				var _needGroupRefresh:Boolean;				public function InputPanel():void		{			_panes = new Array();			_clusters = new Array();			_clusterId = new Array();			//_messages = new Array();			_textFormats = new Object();			_accordianState = new Dictionary(true);   // using weak keys						_createComponents();		}				public function get templateSet():PosterTemplateSet		{			return _curSet;		}				public function set templateSet(value:PosterTemplateSet):void		{			if (value !== _curSet)			{				_saveAccordianState();   // before changing, record which panes are open in the current set				_curSet = value;				// remove the paper options in the combo box and put in new ones				_sizeCombo.removeAll();				for each (var poster:PosterTemplate in _curSet.templates)				{					_sizeCombo.addItem({label: poster.label, data: poster});				}				_sizeCombo.selectedIndex = _curSet.currentIndex;				// this will match MessageGroup objects to the textareas in the poster template				// and create all the associated radio buttons and accordian panes				_rebuildMessageDisplay();			}		}				public function get textFormats():Object		{			return _textFormats;		}				public function set textFormats(value:Object):void		{			if (value != null && value !== _textFormats)			{				_textFormats = value;				// format the combo box. if the number of steps it takes to apply the text formatting				// seems ridiculous, it's because it is.				if ('embedFonts' in _textFormats)				{					_sizeCombo.setStyle('embedFonts', _textFormats.embedFonts);					_sizeCombo.dropdown.setStyle('embedFonts', _textFormats.embedFonts);					_sizeCombo.textField.setStyle('embedFonts', _textFormats.embedFonts);				}				if ('paperSelector' in _textFormats)				{					_sizeCombo.setStyle('textFormat', _textFormats.paperSelector);					_sizeCombo.dropdown.setStyle('textFormat', _textFormats.paperSelector);					_sizeCombo.textField.setStyle('textFormat', _textFormats.paperSelector);					_sizeCombo.dropdown.setStyle('cellRenderer', CustomCellRenderer);					//setSize(width, height);  // reposition components, in case the combo box changed size				}								for each (var cluster:MessageRadioCluster in _clusters)				{					cluster.textFormats = _textFormats;				}				for each (var pane:AccordianPane in _panes)				{					pane.textFormats = _textFormats;				}								_updateScrollerLater(true);  // argument tells it to also call refresh() on group			}		}				override public function set width(value:Number):void		{			if (value != width)  setSize(value, height);		}				override public function set height(value:Number):void		{			if (value != height)  setSize(width, value);		}				public function setSize(newWidth:Number, newHeight:Number):void		{			if (newWidth > 0 && newHeight > 0)			{				// resize the combo box				_sizeCombo.width = newWidth - _scroller.verticalScrollBar.width;				_sizeCombo.x = 0;				_sizeCombo.y = 0;								// resize the scrollpane				_scroller.width = newWidth;				_scroller.x = 0;				_scroller.y = _sizeCombo.height + COMBO_SPACING;				_scroller.height = newHeight - _scroller.y;								// resize everything inside the scrollpane, and save the width for when new				// panes and clusters are created				_contentWidth = newWidth - _scroller.verticalScrollBar.width - SCROLLER_GUTTER;				for each (var cluster:MessageRadioCluster in _clusters)				{					cluster.width = _contentWidth;				}				_group.width = newWidth;			}		}				/*public function setMessages(newMessages:Array):void		{			// delete the old message structure			for (var n:String in _messages)			{				delete _messages[n];			}			// now separate the array of messages based on type			for each (var msg:MessageGroup in newMessages)			{				if (!(msg.type in _messages))				{					_messages[msg.type] = new Array();				}				_messages[msg.type].push(msg);			}			_matchMessagesToTemplate();		}*/				private function _createComponents():void		{			var spSkin:Shape = new Shape();			spSkin.graphics.beginFill(0xFFFFFF, 0.0);			spSkin.graphics.drawRect(0, 0, 50, 50);			spSkin.graphics.endFill();						_scroller = new ScrollPane();			_scroller.scrollDrag = false;			_scroller.setStyle("skin", spSkin);			_scroller.setStyle("upSkin", spSkin);			_scroller.horizontalScrollPolicy = ScrollPolicy.OFF;			_scroller.verticalScrollPolicy = ScrollPolicy.AUTO;			addChild(_scroller);						_sizeCombo = new ComboBox();			_sizeCombo.prompt = PAPER_PROMPT;			_sizeCombo.editable = false;			_sizeCombo.addEventListener(Event.CHANGE, _sizeComboChangeHandler);			addChild(_sizeCombo);						_group = new AccordianGroup();			_group.multiOpen = false;			_group.addEventListener(Event.CHANGE, _groupChangeHandler);			_scroller.source = _group;		}				// clear out existing MessageRadioClusters and the accordian structure and rebuild it using the		// settings in the current template set. mostly called when the template set changes, but 		// might be called after a size change if the text areas changed between sizes		private function _rebuildMessageDisplay():void		{			// clear out the existing radio clusters and accordian panes. suppress the group 			// change handler; we already know the group is changing			_group.removeEventListener(Event.CHANGE, _groupChangeHandler);			_group.removeAllPanes();			for (var i:int = 0; i < _panes.length; i++)			{				_panes[i].content = null;				_clusters[i].removeEventListener(Event.CHANGE, _clusterChangeHandler);				//_clusters[i].removeEventListener(ComponentEvent.LABEL_CHANGE, _clusterLabelChangeHandler);			}			_panes.splice(0);     // delete all of the panes			_clusters.splice(0);  // and all the radio clusters			_clusterId.splice(0);						// make sure there's something to add. if no current template is defined,			// there are no textareas to match against			if (_curSet == null || _curSet.current == null)			{				_updateScrollerLater();  // still need to do this, since the pane changed				return;			}						// look at each textarea in the template, then look at the template set for the MessageGroup			// associated with the id of that textarea			for each (var area:PosterTextArea in _curSet.current.textAreas)			{				// every text area in the PosterTemplateSet should be in the messageMap, but check				// just to be safe				if (area.id in _curSet.messageMap && _curSet.messageMap[area.id].group != null)				{					// duplicate the message list from the associated group so a user-supplied message					// can be added to the end, if one is defined					var msgList:Array = _curSet.messageMap[area.id].group.messages.slice();					var current:Message = _curSet.messageMap[area.id].current;					var userMsg:Message = _curSet.messageMap[area.id].user;					if (userMsg != null)  msgList.push(userMsg);										// pass the message list to a MessageRadioCluster, which will format the messages 					// into radio buttons. this is where the user will change poster text, so listen for					// the change events					var newCluster:MessageRadioCluster = new MessageRadioCluster(msgList);					newCluster.defaultLabel = MESSAGE_PROMPT;					newCluster.textFormats = _textFormats;					newCluster.width = _contentWidth					// selection has to be set before adding the event listener. otherwise, the change triggers					// the event, which is likely to fail because the data structures aren't filled yet					if (current != null)  newCluster.selection = current;					newCluster.addEventListener(Event.CHANGE, _clusterChangeHandler);					//newCluster.addEventListener(ComponentEvent.LABEL_CHANGE, _clusterLabelChangeHandler);					_clusters.push(newCluster);					_clusterId.push(area.id);										// create an AccordianPane to hold the cluster, which uses the PosterTextArea's label					// as a title. add the new pane to the AccordianGroup					var newPane:AccordianPane = new AccordianPane(area.label, newCluster);					newPane.expandIcon = new EXPAND_ICON();					newPane.contractIcon = new CONTRACT_ICON();					newPane.textFormats = _textFormats;					newPane.width = _contentWidth					if (_curSet in _accordianState && area.id in _accordianState[_curSet])					{						newPane.expanded = _accordianState[_curSet][area.id];					}					_panes.push(newPane);					_group.addPane(newPane);				}			}			// put the AccordianGroup handler back in place, now that the panes are all updated			_group.addEventListener(Event.CHANGE, _groupChangeHandler);			// make the scroll bar update, and call refresh() on the group			_updateScrollerLater(true);		}		// this should be called before _rebuildMessageDisplay, but before the template set changes,		// to save the open/close state of the accordian panes. the state will be used if the 		// template set is loaded again, so that the same panes are expanded		private function _saveAccordianState():void		{			if (!(_curSet in _accordianState))			{				_accordianState[_curSet] = new Object();			}						for (var i:int = 0; i < _clusters.length; i++)			{				_accordianState[_curSet][ _clusterId[i] ] = _panes[i].expanded;			}		}				// When the height of the content inside the scrollpane changes (which it does		// anytime an accordian pane inside it opens or closes), the pane has to be told		// to update its scrollbars. but if it's told to do that too early, it gets it wrong,		// maybe because the content hasn't settled on a final size yet. 		// About the only way I've found to make the scrollpane reliably find the size is to		// delay the update by a frame, so the content gets rendered at the right size during		// the RENDER event of this frame, then the scrollbar gets updated during ENTER_FRAME		// of the next one. this introduced a slight delay in the update, but unless the frame		// rate is set low, it's barely noticable. One catch: this whole process only works		// if the stage is available.		// This function starts this delayed update, by registering for RENDER if there is a		// stage, or otherwise waiting for the stage		private function _updateScrollerLater(updateGroup:Boolean = false):void		{			_needGroupRefresh = updateGroup;			if (stage != null)			{				stage.addEventListener(Event.RENDER, _renderHandler);				stage.invalidate();			}			else			{				addEventListener(Event.ADDED_TO_STAGE, _stageAddedHandler);			}		}				private function _sizeComboChangeHandler(e:Event):void		{			var prevIndex:int = _curSet.currentIndex;			_curSet.currentIndex = _sizeCombo.selectedIndex;			// check to see if the message radio buttons need to be rebuilt. usually, they won't need to,			// since most template sets should have the same textareas in every template. that's not a 			// requirement, though, so check that the textareas in the previous and current selection			// match up in size and in the ID of the textareas at each position			var needRebuild:Boolean = false;			if (_curSet.templates[prevIndex].textAreas.length != _curSet.current.textAreas.length)			{				needRebuild = true;			}			else			{				var oldAreas:Array = _curSet.templates[prevIndex].textAreas;				var newAreas:Array = _curSet.current.textAreas;				for (var i:int = 0; i < newAreas.length; i++)				{					if (oldAreas[i].id != newAreas[i].id)					{						needRebuild = true;						break;					}				}			}			// if something didn't match up, rebuild the message radios and accordian			if (needRebuild)			{				_saveAccordianState();				_rebuildMessageDisplay();			}						dispatchEvent(new Event(InputPanel.SIZE_CHANGE, true));		}				// user changed the selected message in one of the clusters, either by clicking a different		// radio button or but typing something in a textfield. figure out which cluster it was		// and what textArea id is associated with it and send out the new message as a MessageChangeEvent		private function _clusterChangeHandler(e:Event):void		{			// the radio button CHANGE events bubble, so they get caught by this handler and need to be filtered out			//if (e.target !== e.currentTarget)  return;			var cluster:MessageRadioCluster = e.currentTarget as MessageRadioCluster;			var idx:int;			for (idx = 0; idx < _clusters.length; idx++)			{				if (_clusters[idx] === cluster)  break;			}			// update the template set to reflect the message choice			_curSet.messageMap[ _clusterId[idx] ].current = cluster.selection;			dispatchEvent(new MessageChangeEvent(InputPanel.TEXT_CHANGE, true, false, _clusterId[idx], cluster.selection));		}				/*private function _clusterLabelChangeHandler(e:ComponentEvent):void		{					}*/				private function _groupChangeHandler(e:Event):void		{			// change events from the radio buttons will also trigger this			// handler when they bubble, so filter those out to make sure the			// code only runs when the AccordianGroup changes			if (e.target !== e.currentTarget)  return;						_updateScrollerLater();		}				// the panel is now on the stage, so register for the RENDER handler, when the		// scrollpane content will get updapted		private function _stageAddedHandler(e:Event):void		{			if (stage != null)			{				removeEventListener(Event.ADDED_TO_STAGE, _stageAddedHandler);				stage.addEventListener(Event.RENDER, _renderHandler);				stage.invalidate();			}		}				// during the render event, the content is probably updating itself. since its		// size might not be finalized yet, the scrollbars will get updated in the next		// frame, so stop listening for RENDER and start listening for ENTER_FRAME		private function _renderHandler(e:Event):void		{			if (stage != null)			{				if (_needGroupRefresh)  _group.refresh();				stage.removeEventListener(Event.RENDER, _renderHandler);				stage.addEventListener(Event.ENTER_FRAME, _frameHandler);			}			else			{				addEventListener(Event.ADDED_TO_STAGE, _stageAddedHandler);			}		}				// new frame is being drawn, finally time to update the scrollpane		private function _frameHandler(e:Event):void		{			if (stage != null)  stage.removeEventListener(Event.ENTER_FRAME, _frameHandler);			if (_scroller != null)  _scroller.update();		}	}}