package edu.uky.comm.rcap{	import flash.display.Sprite;	import flash.display.DisplayObject;	import flash.events.Event;	import flash.text.TextFormat;		import fl.controls.RadioButtonGroup;	import fl.controls.RadioButton;	import fl.events.ComponentEvent;		import edu.uky.comm.controls.MultilineRadioButton;	import edu.uky.comm.controls.TextfieldRadioButton;		import edu.uky.comm.rcap.Message;	import edu.uky.comm.rcap.MessageGroup;	import edu.uky.comm.rcap.MessageSource;		public class MessageRadioCluster extends Sprite	{		private static const BUTTON_SPACING:Number = 10;		private static const DEFAULT_WIDTH:Number = 200;		private static const TEXTFIELD_HEIGHT:Number = 50;		// the names of the various radio button groups really don't matter, they just need		// to be unique. so each new MessageRadioCluster object will create a group with		// the given prefix and a number that's incremented each time		private static const RADIOGROUP_NAME_PREFIX:String = "rcapMsgGroup";		private static var _radiogroupNameCounter:int = 1;		private var _messages:Array;		private var _radioGroup:RadioButtonGroup;		private var _radios:Array;		private var _width:Number;		private var _defaultLabel:String;		private var _textFormats:Object;				private var _addedEventsSeen:int;				public function MessageRadioCluster(group:Array = null):void		{			_width = DEFAULT_WIDTH;			_textFormats = new Object();						// create a new radio button group using the prefix and static number declared above,			// and increment the number in the process			_radioGroup = new RadioButtonGroup(RADIOGROUP_NAME_PREFIX + _radiogroupNameCounter++);			_radioGroup.addEventListener(Event.CHANGE, _passEvent, false, 0, true);			_radios = new Array();			messages = group;		}				public function get messages():Array		{			return _messages;		}				public function set messages(group:Array):void		{			_messages = group;			if (_messages != null)  refresh();		}				public function get selection():Message		{			var idx:int = this.selectionIdx;			return (idx < 0) ? null : _messages[idx];		}				public function set selection(value:Message):void		{			for (var i:int = 0; i < _messages.length; i++)			{				if (_messages[i] === value)				{					selectionIdx = i;					break;				}			}		}				public function get selectionIdx():int		{			return _radioGroup.getRadioButtonIndex(_radioGroup.selection);		}				public function set selectionIdx(value:int):void		{			if (value >= 0 && value < _radios.length)			{				_radios[value].selected = true;			}		}				override public function set width(value:Number):void		{			if (value > 0)			{				_width = value;				// resize all the radio buttons				for each (var rb:RadioButton in _radios)				{					rb.width = _width;				}				if (stage != null)  _requestRearrange();			}		}				public function get defaultLabel():String		{			return _defaultLabel;		}				public function set defaultLabel(value:String)		{			_defaultLabel = value;			// now update any TextfieldRadioButton objects that exist			for each (var rb:RadioButton in _radios)			{				if (rb is TextfieldRadioButton)				{					rb.label = _defaultLabel;				}			}		}				public function get textFormats():Object		{			return _textFormats;		}				public function set textFormats(value:Object):void		{			if (value != null && value !== _textFormats)			{				_textFormats = value;				for each (var rb:RadioButton in _radios)				{					_applyTextFormats(rb);				}				if (stage != null)  _requestRearrange();			}		}				public function refresh():void		{			// don't do anything if there's no data source			if (_messages == null)  return;			while (numChildren > 0)			{				removeChildAt(0);			}						// first clear out the existing radio buttons, if there are any			for each (var oldRb:RadioButton in _radios)			{				oldRb.groupName = null;  // will call removeRadioButton() for the group			}			_radios.splice(0);  // delete them all						// now create the buttons			_addedEventsSeen = 0;   // reset this each time refresh() is called			for each (var msg:Message in _messages)			{				var rb:RadioButton;				// if the message came from user input, make a radio button that accepts				// user input. otherwise, make a standard radiobutton that displays a 				// static label				if (msg.source == MessageSource.USER)				{					rb = new TextfieldRadioButton();					rb.label  = _defaultLabel;					rb.height = TEXTFIELD_HEIGHT;					if (msg.text != null && msg.text.length > 0)  TextfieldRadioButton(rb).userText = msg.text;					rb.addEventListener(ComponentEvent.LABEL_CHANGE, _labelChangeHandler, false, 0 , true);				}				else				{					rb = new MultilineRadioButton();					rb.label = msg.text;				}				rb.group = _radioGroup;  // automatically adds it to the group				rb.x = 0;				rb.width = _width;				_applyTextFormats(rb);				_radios.push(rb);				// listen for the ADDED_TO_STAGE event so the y value can be set. each button's y value				// depends on the height of the previous button, but the height can't be acurately				// determined until after the TextFormats are applied, and that isn't done until				// the buttons have been added to the display list				rb.addEventListener(Event.ADDED_TO_STAGE, _addedHandler, false, 0, true);				addChild(rb);			}		}				private function _applyTextFormats(rb:RadioButton):void		{			// for each possible format, see if it's defined in the textFormats object.			// if it isn't, set the style to null so it'll use a default			if ('default' in _textFormats && _textFormats.default is TextFormat)			{				rb.setStyle('textFormat', _textFormats.default);			}			else			{				rb.setStyle('textFormat', null);			}						if ('disabled' in _textFormats && _textFormats.disabled is TextFormat)			{				rb.setStyle('disabledTextFormat', _textFormats.disabled);			}			else			{				rb.setStyle('disabledTextFormat', null);			}						if ('embedFonts' in _textFormats && _textFormats.embedFonts)			{				rb.setStyle('embedFonts', true);			}			else			{				rb.setStyle('embedFonts', false);			}						// emptyTextFormat only applies to TextfieldRadioButton instances			if (rb is TextfieldRadioButton)			{				if ('empty' in _textFormats && _textFormats.empty is TextFormat)				{					rb.setStyle('emptyTextFormat', _textFormats.empty);				}				else				{					rb.setStyle('emptyTextFormat', null);				}			}		}				private function _arrangeRadioButtons():void		{			if (_radios.length > 0)   // make sure there's somethng to work on			{				// first one is easy, it's moved down by however much the gutter amount				//_radios[0].y = BUTTON_SPACING;				_radios[0].y = 0;				// now position the rest of them based on the y and height of the previous				// radio button, plus the gutter amount				for (var i:int = 1; i < _radios.length; i++)				{					_radios[i].y = _radios[i-1].y + _radios[i-1].textField.textHeight + BUTTON_SPACING;				}			}		}				private function _requestRearrange():void		{			if (stage != null)			{				stage.addEventListener(Event.RENDER, _renderHandler, false, 0, true);				stage.invalidate();			}			else			{				addEventListener(Event.ADDED_TO_STAGE, _addedToStageHandler, false, 0, true);			}		}				private function _addedToStageHandler(e:Event):void		{			removeEventListener(Event.ADDED_TO_STAGE, _addedToStageHandler);			stage.addEventListener(Event.RENDER, _renderHandler, false, 0, true);			stage.invalidate();		}				private function _addedHandler(e:Event):void		{			var rb:RadioButton = e.target as RadioButton;			// stop listening for ADDED after the first time			rb.removeEventListener(Event.ADDED_TO_STAGE, _addedHandler);			// count this event			_addedEventsSeen++;			// now check to see if this is the last button to be added to the stage event.			// if it is, they're ready to be positioned... sort of. once they're all on the stage,			// request a RENDER event (so they can be re-arranged right before a screen refresh),			// then invalidate() the stage to trigger the RENDER			if (_addedEventsSeen == _messages.length)			{				_requestRearrange();			}		}		private function _renderHandler(e:Event):void		{			// screen is about to refresh and all the buttons are added, so put them in place.			// only need to do this once, so get rid of the RENDER event too			if (stage != null)  stage.removeEventListener(Event.RENDER, _renderHandler);			_arrangeRadioButtons();		}				// take an event dispatched by RadioButtonGroup or TextfieldRadioButton		// and re-dispatch it for MessageRadioCluster listeners		private function _passEvent(e:Event):void		{			dispatchEvent(e);		}				private function _labelChangeHandler(e:ComponentEvent):void		{			var curRadio:RadioButton = e.target as RadioButton;			if (!(curRadio is TextfieldRadioButton))  return;						// figure out where the radio button that dispatched this is in the			// list of buttons because the message needs to be updated and the two			// share indexes			var idx:int;			for (idx = 0; idx < _radios.length; idx++)			{				if (_radios[idx] === curRadio)  break;			}						_messages[idx].text = TextfieldRadioButton(curRadio).userText;						dispatchEvent(e);			dispatchEvent(new Event(Event.CHANGE));		}	}}