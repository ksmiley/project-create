package edu.uky.comm.rcap{	import flash.geom.Matrix;		import edu.uky.comm.rcap.PosterTemplateSet;	import edu.uky.comm.rcap.PosterTextArea;	import edu.uky.comm.rcap.PosterImage;		public class PosterTemplate	{		private static const POINTS_PER_INCH = 72;				// get accessors are provided for these. first two are read-only because they're set by		// scaleToBounds(). the physical dimensions are set by the constructor and are used to		// setup all child objects. changing them would require adjusting all the children, 		// but the original data to do so might not be available anymore		private var _width:Number;  // width in inches of the full poster		private var _height:Number; // height in inches of the full poster		private var _resolution:Number;		// number between 0 and 1 that relates the physical size to the preview size.		// set by scaleToBounds(), this is read-only, so a get function is provided		private var _scaleFactor:Number;				private var _label:String;		public var paperOptions:Array;  // Array of Strings		public var backgroundColor:uint;				public var images:Array;  // Array of PosterImage objects		public var textAreas:Array; // Array of PosterTextArea objects				public var templateSet:PosterTemplateSet;				public function PosterTemplate(origWidth:Number, origHeight:Number, ppi:Number, set:PosterTemplateSet = null):void		{			templateSet = set;						_width = origWidth;			_height = origHeight;			_resolution = ppi;						images = new Array()			textAreas = new Array();			paperOptions = new Array();						backgroundColor = 0xFFFFFFFF;			_scaleFactor = 1;		}				public function clone():PosterTemplate		{			var cloned:PosterTemplate = new PosterTemplate(_width, _height, _resolution);			cloned.scaleFactor = _scaleFactor;			cloned.label = label;			cloned.backgroundColor = backgroundColor;						var cloneChild:Function = function (o:*):Object { return o.clone(cloned); };			cloned.images = images.map(cloneChild);			cloned.textAreas = textAreas.map(cloneChild);			cloned.paperOptions = paperOptions.slice();						return cloned;		}				// calls destroy() on all the child images and sets arrays to null, to eliminate circular references		// and allow garbage collection to happen		public function destroy():void		{			for each (var i:PosterImage in images)			{				i.destroy();			}			images = null;						for each (var t:PosterTextArea in textAreas)			{				t.destroy();			}			textAreas = null;			templateSet = null;		}				// uses the current resolution setting to convert the given value in inches		// to the number of pixels it represents		public function inchesToPixels(inches:Number):Number		{			return inches * _resolution;		}				// uses the current resolution setting to convert the given value in points		// (such as for a font) to the number of pixels it represents		public function pointsToPixels(points:Number):Number		{			return (points / POINTS_PER_INCH) * _resolution;		}				// maxWidth and maxHeight are in pixels and represent a bounding box.		// physicalWidth, physicalHeight and resolution must be set. they will be converted from inches		// to pixels, then proportionally scaled to fit within the given bounding box. scaleFactor is set		// to the calculated value, and the width and height properties are set to the new values.		// if cascade is true, the calculated scaleFactor is then passed to all the children objects,		// so they are all scaled to the new value		public function scaleToBounds(maxWidth:Number, maxHeight:Number):void		{			// convert inches to physical pixels			var oldWidth:Number = inchesToPixels(_width);			var oldHeight:Number = inchesToPixels(_height);			var xFactor:Number = maxWidth / oldWidth;   // how much scaling needed to fit horizontally?			var yFactor:Number = maxHeight / oldHeight; // how much scaling needed to fit vertically?			_scaleFactor = (xFactor < yFactor) ? xFactor : yFactor;  // use the smaller of the two, so both fit		}				// takes a message type and returns an array of PosterTextArea objects that match that type		public function getTextAreasByType(searchType:String):Array		{			var matches:Array = new Array();			for each (var area:PosterTextArea in textAreas)			{				if (area.type == searchType)				{					matches.push(area);				}			}			return matches;		}				public function getTextArea(searchId:String):PosterTextArea		{			for each (var area:PosterTextArea in textAreas)			{				if (area.id == searchId)  return area;			}			return null;		}				public function getTextAreaIndex(searchId:String):int		{			for (var i:int = 0; i < textAreas.length; i++)			{				if (textAreas[i].id == searchId)  return i;			}			return -1;  // no match		}				public function getImage(searchId:String):PosterImage		{			for each (var img:PosterImage in images)			{				if (img.id == searchId)  return img;			}			return null;		}				public function getImageIndex(searchId:String):int		{			for (var i:int = 0; i < images.length; i++)			{				if (images[i].id == searchId)  return i;			}			return -1;  // no match		}				public function get label():String		{			if (_label)			{				return _label;			}			else			{				// default is something like 11" x 17"				return _width + '" x ' + _height + '"';			}		}				public function set label(text:String):void		{			_label = text;		}				public function get width():Number		{			return _width;		}				public function get height():Number		{			return _height;		}				public function get previewWidth():Number		{			return Math.floor(inchesToPixels(_width) * _scaleFactor);		}				public function get previewHeight():Number		{			return Math.floor(inchesToPixels(_height) * _scaleFactor);		}				public function get resolution():Number		{			return _resolution;		}				public function get scaleFactor():Number		{			return _scaleFactor;		}				public function set scaleFactor(scale:Number):void		{			_scaleFactor = scale;		}				public function get scaleMatrix():Matrix		{			return new Matrix(_scaleFactor, 0, 0, _scaleFactor);		}	}}