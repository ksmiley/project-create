package edu.uky.comm.rcap{	import edu.uky.comm.rcap.PosterTemplate;	import edu.uky.comm.rcap.PosterTextArea;	import edu.uky.comm.rcap.MessageGroup;	import edu.uky.comm.rcap.Message;		public class PosterTemplateSet	{		public var templates:Array;		public var id:String;		public var messageMap:Object;				private var _curTemplate:int;				public function PosterTemplateSet():void		{			templates = new Array();			_curTemplate = -1;		}				public function get current():PosterTemplate		{			return (_curTemplate >= 0 ? templates[_curTemplate] : null);		}				public function set current(value:PosterTemplate):void		{			var found:Boolean = false;			for (var i:Number = 0; i < templates.length; i++)			{				if (templates[i] === value)				{					_curTemplate = i;					found = true;					break;				}			}			if (!found)			{				throw new ArgumentError("Template not found in set");			}		}				public function get currentIndex():int		{			return _curTemplate;		}				public function set currentIndex(value:int):void		{			if (value >= 0 && value < templates.length && templates[value] is PosterTemplate)			{				_curTemplate = value;			}			else			{				throw new ArgumentError("No template defined at index " + value);			}		}				public function setMessages(groups:Array):void		{			messageMap = new Object();   // empty out the existing map						// first separate the message groups into different lists based on their			// type, since that's what will be used to match them to textareas.			// the counters object is used in the last step, to keep track of what the			// next group group to assign is in each list			var sortedGroups:Object = new Object();			var counters:Object = new Object();			for each (var g:MessageGroup in groups)			{				if (!(g.type in sortedGroups))				{					sortedGroups[g.type] = new Array();					counters[g.type] = 0;				}				sortedGroups[g.type].push(g);			}						// now search through the templates and find the unique textareas			for each (var tmpl:PosterTemplate in templates)			{				for each (var area in tmpl.textAreas)				{					if (!(area.id in messageMap))					{						messageMap[area.id] = new Object();						messageMap[area.id].type = area.type;					}				}			}						// finally, assign a MessageGroup to each textarea			for each (var uniqueId:Object in messageMap)			{				if (uniqueId.type in sortedGroups)				{					uniqueId.group = sortedGroups[uniqueId.type][ counters[uniqueId.type] ];					uniqueId.current = null;					counters[uniqueId.type]++;					// increase the position counter for this message type. if it goes over the					// size of the message list, wrap it around to the beginning					if (counters[uniqueId.type] >= sortedGroups[uniqueId.type].length)					{						counters[uniqueId.type] = 0;					}				}			}		}				public function getTemplateByLabel(searchLabel:String):PosterTemplate		{			var match:PosterTemplate = null;			for each (var tmpl:PosterTemplate in templates)			{				if (tmpl.label == searchLabel)				{					match = tmpl;					break				}			}			return match;		}				// calls scaleToBounds() on each child template with the given values		public function scaleToBounds(maxWidth:Number, maxHeight:Number):void		{			for each (var t:PosterTemplate in templates)			{				t.scaleToBounds(maxWidth, maxHeight);			}		}	}}