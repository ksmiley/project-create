package edu.uky.comm.rcap{	import flash.text.Font;	import flash.filters.GlowFilter;	import flash.filters.DropShadowFilter;		import edu.uky.comm.rcap.Message;	import edu.uky.comm.rcap.MessageType;	import edu.uky.comm.rcap.PosterTemplate;		public class PosterTextArea	{		// auto-resizing constants		public static const PROPORTIONAL = "proportional";		public static const MATCHPAGE    = "matchpage";				// oversides constants		public static const OVER_SHRINK = "shrink";		public static const OVER_SHIFT  = "shift";				// text stroke is implemented using a GlowFilter. to vary the weight, both blur and strength		// need to be adjusted. the blur values are set to weight, and strength is set to		// weight times this constant		private static const BLUR_MULTIPLIER = 2;				public var id:String;		public var type:String = MessageType.TAGLINE;		private var _label:String;				public var x:Number;		public var y:Number;		public var width:Number;		public var height:Number;				public var resize:String = PosterTextArea.PROPORTIONAL;		public var oversides:String = PosterTextArea.OVER_SHRINK;				public var color:uint;		public var alpha:Number;				public var font:Font;		public var fontName:String;		public var fontSize:Number;		public var fontMinSize:Number;		public var tracking:Number;		public var leading:Number;		public var align:String;				public var useStroke:Boolean;		public var _strokeFilter:GlowFilter;		private var _strokeColor:uint;    // these use accessors so they can update the filter		private var _strokeWeight:Number;				public var useShadow:Boolean;		public var _shadowFilter:DropShadowFilter;		private var _shadowColor:uint;    // these use accessors so they can update the filter		private var _shadowAlpha:Number;		private var _shadowBlur:Number;		private var _shadowAngle:Number;		private var _shadowDistance:Number;				public var template:PosterTemplate;					// constructor		public function PosterTextArea(page:PosterTemplate):void		{			template = page;						alpha = 1;						// set up filter objects. the other properties of these will be set by the various accessors			useStroke = false;			_strokeFilter = new GlowFilter();			_strokeFilter.alpha = 0.9;			strokeColor = 0xFF000000;  // default color is black			strokeWeight = 2;						useShadow = false;			_shadowFilter = new DropShadowFilter();			shadowColor = 0xFF000000;			shadowAlpha = 0.8;			shadowBlur = 8;			shadowAngle = 60;			shadowDistance = 10;		}				public function clone(page:PosterTemplate = null):PosterTextArea		{			var cloned:PosterTextArea = new PosterTextArea((page == null) ? template : page);			var cloneProps:Array = 			['id', 'type', '_label', 'x', 'y', 'width', 'height', 'resize', 'oversides', 'color', 'alpha',			 'font', 'fontName', 'fontSize', 'fontMinSize', 'tracking', 'leading', 'align',			 'useStroke', '_strokeColor', '_strokeWeight',			 'useShadow', '_shadowColor', '_shadowAlpha', '_shadowBlur', '_shadowAngle', '_shadowDistance'];			for each (var prop:* in cloneProps)			{				cloned[prop] = this[prop];			}			cloned.shadowFilter = DropShadowFilter(shadowFilter.clone());			cloned.strokeFilter = GlowFilter(strokeFilter.clone());			return cloned;		}				public function destroy():void		{			template = null;  // prevent circular reference			_strokeFilter = null;			_shadowFilter = null;		}				// retrieve the current Message value for this textarea, if it's available.		// the PosterTemplateSet handles mapping textarea IDs to messages, so try to find		// the parent PosterTemplateSet, then see if it has a message map set, and if so,		// if it has this PosterTextArea's id in it		public function get value():Message		{			var msg:Message = null;			if (template != null && template.templateSet != null)			{				var map:Object = template.templateSet.messageMap;				if (map != null && id in map && 'current' in map[id])				{					msg = map[id].current;				}			}			return msg;		}				public function get label():String		{			if (_label)			{				return _label;			}			else			{				return "Text " + id;			}		}				public function set label(text:String):void		{			_label = text;		}				public function get previewX():Number		{			return Math.floor(x * this.template.scaleFactor);		}				public function get previewY():Number		{			return Math.floor(y * this.template.scaleFactor);		}				public function get previewWidth():Number		{			return Math.floor(width * this.template.scaleFactor);		}				public function get previewHeight():Number		{			return Math.floor(height * this.template.scaleFactor);		}				public function get previewFontSize():Number		{			return Math.floor(fontSize * this.template.scaleFactor);		}				public function get previewFontMinSize():Number		{			return Math.floor(fontMinSize * this.template.scaleFactor);		}				public function get previewTracking():Number		{			return Math.floor(tracking * this.template.scaleFactor);		}				public function get previewLeading():Number		{			return Math.floor(leading * this.template.scaleFactor) - this.previewFontSize;		}				// accessors for stroke, which both update the variables and the GlowFilter settings		public function get strokeFilter():GlowFilter		{			return _strokeFilter;		}				public function set strokeFilter(filter:GlowFilter):void		{			_strokeFilter = filter;		}				public function get strokeColor():uint		{			return _strokeColor;		}				public function set strokeColor(color:uint):void		{			_strokeColor = color;			_strokeFilter.color = color;		}				public function get strokeWeight():Number		{			return _strokeWeight;		}				public function set strokeWeight(weight:Number):void		{			_strokeWeight = weight;			_strokeFilter.blurX = weight;			_strokeFilter.blurY = weight;			_strokeFilter.strength = weight * BLUR_MULTIPLIER;		}				// accessors for shadow, which both update the variables and the DropShadowFilter settings				public function get shadowFilter():DropShadowFilter		{			_shadowFilter.distance = _shadowDistance * this.template.scaleFactor;			return _shadowFilter;		}				public function set shadowFilter(filter:DropShadowFilter):void		{			_shadowFilter = filter;		}				public function get shadowColor():uint		{			return _shadowColor;		}				public function set shadowColor(color:uint):void		{			_shadowColor = color;			_shadowFilter.color = color;		}				public function get shadowAlpha():Number		{			return _shadowAlpha;		}				public function set shadowAlpha(alpha:Number):void		{			_shadowAlpha = alpha;			_shadowFilter.alpha = alpha;		}				public function get shadowBlur():Number		{			return _shadowBlur;		}				public function set shadowBlur(blur:Number):void		{			_shadowBlur = blur;			_shadowFilter.blurX = _shadowFilter.blurY = blur;		}				public function get shadowAngle():Number		{			return _shadowAngle;		}				public function set shadowAngle(angle:Number):void		{			_shadowAngle = angle;			_shadowFilter.angle = angle;		}				public function get shadowDistance():Number		{			return _shadowDistance;		}				public function set shadowDistance(distance:Number):void		{			_shadowDistance = distance;			_shadowFilter.distance = distance * this.template.scaleFactor;		}	}}