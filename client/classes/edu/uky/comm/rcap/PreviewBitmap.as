package edu.uky.comm.rcap{	import flash.display.Sprite;	import flash.display.Bitmap;	import flash.display.BitmapData;	import flash.geom.Matrix;		import edu.uky.comm.rcap.RenderPreview;		public class PreviewBitmap extends Sprite	{		private var _maxWidth:Number;   // if these are non-null and non-zero, the Preview will be proportionally scaled down		private var _maxHeight:Number;  // (after rasterizing) to fit within these bounds. these can be changed with accessors.		private var _renderer:RenderPreview;   // passed to the constructor and can't be changed		private var _image:Bitmap;    // Bitmap object that's added as a child of the PreviewBitmap. only used internally		private var _imageData:BitmapData;  // can be retrieved (though not changed) using bitmapData accessor		private var _bitmapSmoothing:Boolean;  // whether to use smoothing when scaling down				public function PreviewBitmap(renderObj:RenderPreview, targetWidth = null, targetHeight = null):void		{			_image = new Bitmap();			addChild(_image);						_renderer = renderObj;			_maxWidth = targetWidth;			_maxHeight = targetHeight;			_bitmapSmoothing = true;			update();		}				public function get maxWidth():Number		{			return _maxWidth;		}				public function set maxWidth(newWidth:Number):void		{			setSize(newWidth, _maxHeight);		}				public function get maxHeight():Number		{			return _maxHeight;		}				public function set maxHeight(newHeight:Number):void		{			setSize(_maxWidth, newHeight);		}				public function get useSmoothing():Boolean		{			return _bitmapSmoothing;		}				public function set useSmoothing(smoothing:Boolean):void		{			if (smoothing != _bitmapSmoothing)			{				_bitmapSmoothing = smoothing;				update();			}		}				public function get renderer():RenderPreview		{			return _renderer;		}				public function get bitmapData():BitmapData		{			return _imageData;		}				public function setSize(targetWidth:Number, targetHeight:Number):void		{			_maxWidth = targetWidth;			_maxHeight = targetHeight;			update();		}				public function update():void		{			if (_renderer != null)			{				var oldWidth:Number = _renderer.width;				var oldHeight:Number = _renderer.height;				_imageData = new BitmapData(oldWidth, oldHeight, true, 0);  // blank canvas, with fully transparent background				_imageData.draw(_renderer);   // rasterize the preview image at its current size				// now see if the full-sized preview image needs to be scaled down. the scaling is done as a separate step				// to force Flash to resize the actual bitmap. if a scaling matrix is passed to the above draw(), it will				// resize the vector representation of the RenderPreview first, then rasterize it.				// if maxWidth or maxHeight are undefined, zero, or negative, don't do any scaling				if ((!isNaN(_maxWidth) && !isNaN(_maxHeight) && _maxWidth > 0 && _maxHeight > 0)					&& (oldWidth > _maxWidth || oldHeight > _maxHeight))				{					var xRatio:Number = _maxWidth / oldWidth;					var yRatio:Number = _maxHeight / oldHeight;					var scaleFactor:Number = (xRatio < yRatio) ? xRatio : yRatio;					var newWidth:Number = oldWidth * scaleFactor;					var newHeight:Number = oldHeight * scaleFactor;					var scaledData:BitmapData = new BitmapData(newWidth, newHeight, true, 0);					// now scale the original image into the new one. colorTransform, blendMode, and clipRect are null,					// and smoothing is true					scaledData.draw(_imageData, new Matrix(scaleFactor, 0, 0, scaleFactor), null, null, null, _bitmapSmoothing);					_imageData = scaledData;   // replace the full-sized data with the scaled				}				// now update the display by making the internal Bitmap use the new data				_image.bitmapData = _imageData;				// and update the PreviewBitmap size to be the same as the data				width = _imageData.width;				height = _imageData.height;			}		}	}}