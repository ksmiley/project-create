package edu.uky.comm.rcap{	import flash.events.Event;	import flash.display.Sprite;	import flash.display.Bitmap;	import flash.display.Shape;	import flash.text.TextField;	import flash.text.TextFormat;	import flash.text.AntiAliasType;	import flash.geom.Matrix;	import flash.geom.Transform;		import edu.uky.comm.rcap.PosterTemplate;	import edu.uky.comm.rcap.PosterImage;	import edu.uky.comm.rcap.PosterTextArea;	import edu.uky.comm.rcap.Message;		public class RenderPreview extends Sprite	{		private static const DEFAULT_OUTLINE_WEIGHT:Number = 0.5;		private static const DEFAULT_OUTLINE_COLOR:uint = 0x333333;		private static const DEFAULT_OUTLINE_HI_COLOR:uint = 0xFF0000;			private var _source:PosterTemplate;		private var _maxWidth:Number;		private var _maxHeight:Number;		private var _showOutlines:Boolean;		private var _outlineWeight:Number;		private var _outlineColor:uint;		private var _outlineHiColor:uint;		private var _highlighted:String;				private var _textIdToField:Object;		private var _textIdToShape:Object;				public function RenderPreview(maxWidth:Number = 0, maxHeight:Number = 0, sourceTmpl:PosterTemplate = null):void		{			// setup index with the id from a PosterTextArea as the key and a TextField			// as the value. used to speed up the updateText() method			_textIdToField = new Object();			// index from id to Shape object that contains a rectangle with the boundaries for that field			_textIdToShape = new Object();						_source = sourceTmpl;			_maxWidth = maxWidth;			_maxHeight = maxHeight;						_showOutlines = false;			_outlineWeight = DEFAULT_OUTLINE_WEIGHT;			_outlineColor = DEFAULT_OUTLINE_COLOR;			_outlineHiColor = DEFAULT_OUTLINE_HI_COLOR;						// setup display properties for self			tabEnabled = false;			tabChildren = false;			mouseChildren = false;			useHandCursor = false;						// if the source and dimensions were all set, this will apply a resize and do an initial draw			_applyResize();		}				public function get source():PosterTemplate		{			return _source;		}				public function set source(newSource:PosterTemplate):void		{			_source = newSource;			_highlighted = null;			_applyResize();		}				public function get maxWidth():Number		{			return _maxWidth;		}				public function set maxWidth(newWidth:Number):void		{			setSize(newWidth, _maxHeight);		}				public function get maxHeight():Number		{			return _maxHeight;		}				public function set maxHeight(newHeight:Number):void		{			setSize(_maxWidth, newHeight);		}		public function get showOutlines():Boolean		{			return _showOutlines;		}				public function set showOutlines(value:Boolean):void		{			if (value != _showOutlines)			{				_showOutlines = value;				for each (var outline:Shape in _textIdToShape)				{					outline.visible = _showOutlines;				}			}		}				public function get outlineWeight():Number		{			return _outlineWeight;		}				public function set outlineWeight(value:Number):void		{			if (value != _outlineWeight)			{				_outlineWeight = value;				redraw();			}		}				public function get outlineColor():uint		{			return _outlineColor;		}				public function set outlineColor(value:uint):void		{			if (value != _outlineColor)			{				_outlineColor = value;				redraw();			}		}				public function get outlineHiColor():uint		{			return _outlineHiColor;		}				public function set outlineHiColor(value:uint):void		{			if (value != _outlineHiColor)			{				_outlineHiColor = value;				if (_highlighted != null)				{					_drawOutline(_highlighted, _textIdToField[_highlighted]);				}			}		}				public function get highlightText():String		{			return _highlighted;		}				public function set highlightText(id:String):void		{			if (id != _highlighted)			{				var oldHighlight:String = _highlighted;				_highlighted = id;				// if another field is already highlighted, update its outline				if (oldHighlight != null && oldHighlight in _textIdToField)				{					_drawOutline(oldHighlight, _textIdToField[oldHighlight]);				}				// now draw the new outline, if one was defined and it matches				// an id of one of the text fields				if (_highlighted != null && _highlighted in _textIdToField)				{					_drawOutline(_highlighted, _textIdToField[_highlighted]);				}			}		}				public function setSize(newWidth:Number, newHeight:Number):void		{			if (newWidth <= 0 || newHeight <= 0)			{				throw new ArgumentError("Render dimensions must be positive and non-zero.");			}			_maxWidth = newWidth;			_maxHeight = newHeight;			_applyResize();		}				public function updateText(txtId:String):void		{			var msgMap:Object = _source.templateSet.messageMap;			// make sure the specified id exists on the current template and that it has			// an entry in the PosterTemplateSet's list of message values			if (txtId in _textIdToField && txtId in msgMap)			{				// get the target text field...				var tf:TextField = _textIdToField[txtId];				// ...and the associated PosterTextArea object				var textArea:PosterTextArea = _source.getTextArea(txtId);				if (msgMap[txtId].current == null || msgMap[txtId].current.text == null)				{					tf.text = "";				}				else				{					tf.text = msgMap[txtId].current.text				}							// Reset the textfield to default formatting and size, then try to avoid text overflow				// by shrinking it to fit, unless automatic shrinking is disabled (as in, fontMinSize = fontSize).				// for text to be considered fitted, two conditions need to be met:				//   1. All the lines of text need to be visible. This is easy to check for, since 				//      flash will report the number of lines in the textfield and what the last visible				//      line is. If the number of lines is greater than the last visible, the text				//      is overflowing				//   2. Long words need to fit on one line. Flash has a pretty brute-force approach to word wrap,				//      so if a word is too long to fit on one line, it'll break it in the middle, or break off				//      punctuation in a way that doesn't work for poster text. The test for this is more 				//      involved. We'll start with tokenizing the string by splitting it at whitespace, then				//      identifying the longest token (which will probably be a word, but could have an apostrophe,				//      trailing period, hyphen, etc.). If the first and last characters of the longest token				//      are on the same line, then all the tokens should be fitting on one line.				var format:TextFormat = tf.defaultTextFormat;				tf.setTextFormat(format);   // reset the formatting to the default				if (tf.text != "" && textArea.previewFontSize != textArea.previewFontMinSize)				{					var fullStr:String = tf.text;					// tokenize the string by splitting on any whitespace					var tokenizePattern:RegExp = /\S+/g;					var tokens:Array = fullStr.match(tokenizePattern);					// find the longest token					var longestToken:String = "";					for each (var oneToken:String in tokens)					{						if (oneToken.length > longestToken.length)  longestToken = oneToken;					}					// find where the longest token starts in the string					var longestStart:int = fullStr.indexOf(longestToken);					var longestEnd:int = longestStart + longestToken.length - 1;										// try to fit the text. first make sure the fontMinSize hasn't been hit. as long as it					// hasn't, shrink the text until the longest token fits on one line					while (format.size > textArea.previewFontMinSize && 						   (tf.getLineIndexOfChar(longestStart) != tf.getLineIndexOfChar(longestEnd))					      )					{						//tf.text = fullStr;						format.size = (format.size as Number) - 1;						tf.setTextFormat(format);					}					// now do the hacked-up text reflow, which tries to keep hyphenated phrases and two-word					// sentences on the same line.					_reflowText(tf);					tf.setTextFormat(format);					while (format.size > textArea.previewFontMinSize && tf.numLines > tf.bottomScrollV)					{						tf.text = fullStr;						format.size = (format.size as Number) - 1;						tf.setTextFormat(format);						_reflowText(tf);						tf.setTextFormat(format);					}				}				// check again to see if it's fitting. if not, throw an overflow error				//if (tf.numLines > tf.bottomScrollV)				//{					// XXX need TextOverflow error				//}			}			else			{				throw new ArgumentError("Template doesn't have a textarea with id '" + txtId + "'");			}		}				private function _reflowText(tf:TextField):void		{			var textWithBreaks:String = "";			for (var i:int = 0; i < tf.numLines; i++)			{				if (textWithBreaks != "")  textWithBreaks = textWithBreaks.concat("\n");				textWithBreaks = textWithBreaks.concat(tf.getLineText(i));			}					var hyphenPattern:RegExp = /(\w+\-)\n/g;			textWithBreaks = textWithBreaks.replace(hyphenPattern, "\n$1");						var shortSentencePattern:RegExp = /(\.\s+)(\w+\s*)\n(\s*\w+\.)/;			while (shortSentencePattern.test(textWithBreaks))			{				textWithBreaks = textWithBreaks.replace(shortSentencePattern, "$1\n$2$3");			}						tf.text = textWithBreaks;		}				public function redraw():void		{			// make sure the necessary properties are set			if (_source == null || _maxWidth < 1 || _maxHeight < 1)			{				throw new ArgumentError("Can't redraw without a data source or image dimensions");			}			// First, create a clean slate						// clear out the old display objects			while (numChildren > 0)			{				removeChildAt(0);			}			// and clear out the textfield index			var fieldId:String;			for (fieldId in _textIdToField)			{				delete _textIdToField[fieldId];			}			// and clear out the shape index			for (fieldId in _textIdToShape)			{				delete _textIdToShape[fieldId];			}			// remove the previous background			graphics.clear();									// Now, start drawing the preview						// draw the new background			graphics.beginFill(_source.backgroundColor);			graphics.drawRect(0, 0, _source.previewWidth, _source.previewHeight);			graphics.endFill();						// create a TextField for each textArea in the template, and format it			// according to the instructions in the PosterTextArea			for each (var txt:PosterTextArea in _source.textAreas)			{				// first set up the formatting for this text field				var format:TextFormat = new TextFormat();				format.font    = txt.font.fontName;				format.kerning = true;				format.size    = txt.previewFontSize;				format.leading = txt.previewLeading;				format.color   = txt.color;				format.align   = txt.align;				if (!isNaN(txt.leading))  format.leading = txt.previewLeading;				if (!isNaN(txt.tracking)) format.letterSpacing = txt.previewTracking;								// create a filter array if there's a stroke or drop shadow				var effects:Array = new Array();				if (txt.useStroke)  effects.push(txt.strokeFilter);				if (txt.useShadow)  effects.push(txt.shadowFilter);								// setup the actual text field to render correctly				var newText:TextField = new TextField();				newText.embedFonts    = true;				newText.antiAliasType = AntiAliasType.ADVANCED;				newText.multiline     = true;				newText.wordWrap      = true;				newText.selectable    = false;				newText.filters       = effects;				newText.defaultTextFormat = format;				newText.x      = txt.previewX;				newText.y      = txt.previewY;				newText.width  = txt.previewWidth;				newText.height = txt.previewHeight;				addChildAt(newText, 0);  // each textfield should go "under" the previous one								_drawOutline(txt.id, newText);  // add a shape representing the text outline								// add the text field to the index so updateText() will work				_textIdToField[txt.id] = newText;				// XXX - need to catch the TextOverflow error?				updateText(txt.id);  // re-flow the text into the field			}						// create a Bitmap for each image in the template			for each (var img:PosterImage in _source.images)			{				var newBitmap:Bitmap = new Bitmap(img.previewData);				// scale the BitmapData to the correct display size				newBitmap.smoothing = true;				newBitmap.transform.matrix = img.bitmapScaleMatrix;				// place the image in the correct place				newBitmap.x      = img.previewX;				newBitmap.y      = img.previewY;				newBitmap.width  = img.previewWidth;				newBitmap.height = img.previewHeight;				addChildAt(newBitmap, 0);  // each image should go "under" the previous one			}						// now that there are objects, re-set the size of the preview			width  = _source.previewWidth;			height = _source.previewHeight;		}				private function _drawOutline(id:String, field:TextField)		{			if (id in _textIdToShape && _textIdToShape[id] != null)			{				removeChild(_textIdToShape[id]);				_textIdToShape[id] = null;			}						var weight:Number = outlineWeight;			var outline:Shape = new Shape();			outline.graphics.lineStyle(weight, (id == _highlighted) ? outlineHiColor : outlineColor);			outline.graphics.drawRect(0, 0, field.width, field.height);			//outline.graphics.drawRect(0, 0, field.width + (weight * 2), field.height + (weight * 2));			//outline.x = field.x - weight;			//outline.y = field.y - weight;			outline.x = field.x;			outline.y = field.y;			outline.visible = _showOutlines;			addChildAt(outline, getChildIndex(field) + 1);			_textIdToShape[id] = outline;		}				private function _applyResize():void		{			if (_source != null && _maxWidth != 0 && _maxHeight != 0)			{				_source.scaleToBounds(_maxWidth, _maxHeight);				redraw();			}		}	}}