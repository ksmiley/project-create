package edu.uky.comm.rcap{	import flash.events.EventDispatcher;   // base class for TemplateLoader	import flash.events.Event;        // the various events the loader handles/dispatches	import flash.events.ErrorEvent;     // dispatched for generic load errors	import flash.events.ProgressEvent;  // dispatched throughout the load process	import flash.events.IOErrorEvent;   // loaders might dispatch this	import flash.events.SecurityErrorEvent;   // loaders might dispatch this	import flash.net.URLLoader;     // used for loading the XML file (text data)	import flash.net.URLRequest;    // used with both types of loaders	import flash.display.BitmapData;   // needed to process the images after loading	import flash.display.Bitmap;       // also needed to get the images after loading	import flash.display.LoaderInfo;   // for extracting progress information	import flash.text.Font;        // for processing the font loads	import flash.geom.Rectangle;   // neeeded to crop the BitmapData after loading	import flash.geom.Point;       // also needed to crop the BitmapData	import flash.system.ApplicationDomain;   // needed to make font loading work	import flash.system.SecurityDomain;      // same	import flash.system.LoaderContext;       // smae	import flash.utils.Dictionary;    // used to map from LoaderInfo to ComponentLoader	// also use flash.display.Loader, but it's extended to create ComponentLoader.	// see the end of this file for that code.		import edu.uky.comm.rcap.Config;   // defines the server path where the data is	import edu.uky.comm.rcap.PosterTemplate;     // Poster* objects get filled with the data	import edu.uky.comm.rcap.PosterTemplateSet;	import edu.uky.comm.rcap.PosterImage;	import edu.uky.comm.rcap.PosterImageCrop;   // needed for some constants	import edu.uky.comm.rcap.PosterTextArea;	import edu.uky.comm.rcap.ParseError;     // thrown when there's a problem with the loaded XML	import edu.uky.comm.rcap.Units;    // has constants for measurement units	import edu.uky.comm.rcap.MessageGroup;  // MessageGroup and Message also create from loaded data	import edu.uky.comm.rcap.Message;	import edu.uky.comm.rcap.MessageSource;   // has some constants	import edu.uky.comm.rcap.MessageType;     // more constants		public class TemplateLoader extends EventDispatcher	{		// custom events that are dispatched just before and just after parsing the XML		public static const PARSE_START:String    = "rcapParseStart";		public static const PARSE_COMPLETE:String = "rcapParseComplete";				private var _parsedTemplates:Array;  // holds the finished object structure parsed out of the XML data		private var _parsedMessages:Array;		private var _loadedImages:Object;  // maps image paths to BitmapData after an image has been fully loaded		private var _parseDone:Boolean;  // set to false while parse is in progress and true once it's finished		private var _loader:URLLoader;				// maps an image path to the ComponentLoader class that's handling it.		// the class is defined at the end of this file.		// the ComponentLoader's targets array will contain PosterImage references		private var _imagesLoading:Object;		// same as above, but uses font names as keys. also, the targets array contains PosterTextArea references		private var _fontsLoading:Object;		// the ComponentLoader has information about the objects being loaded, which is needed for tracking progress		// and other events, but those are dispatched by the child LoaderInfo. the child won't let event handlers		// access its loader property to get the parent until after the INIT event, which comes after most (usually all)		// of the progress events. so this Dictionary uses LoaderInfo objects as keys and ComponentLoaders as values,		// so event handlers can figure out which loader they're acting on		private var _loaderLookup:Dictionary;				private var _bytesLoaded:Number;		private var _bytesTotal:Number;				private var _modelTmpl:PosterTemplate;  // used during parsing for "inheriting" images and textareas				public function TemplateLoader(input:XML = null):void		{			_parseDone = false;						_loadedImages = new Object();			_imagesLoading = new Object();			_fontsLoading = new Object();			_loaderLookup = new Dictionary(true);  // true means use weak keys						_bytesLoaded = 0;			_bytesTotal = 0;						if (input)			{				parse(input);  // ignore return value			}		}				// frees up the resources held by the loader, most notably the BitmapData in the _loadedImages list		public function destroy():void		{			_parsedTemplates = null;			_parsedMessages = null;			_loadedImages = null;			_imagesLoading = null;			_fontsLoading = null;			_loaderLookup = null;			_bytesLoaded = 0;			_bytesTotal = 0;			_modelTmpl = null;		}				// cancel the entire loading process and clean up anything that's been fetched. this renders the current		// TemplateLoader object unusable for loading, so a new one should be created.		public function stop():void		{			if (_loader != null)			{				_loader.close();			}			for each (var l:ComponentLoader in _loaderLookup)			{				l.close();			}			this.destroy();  // clean up the mess		}				public function get parsedTemplates():Array		{			return _parsedTemplates;		}				public function get parsedMessages():Array		{			return _parsedMessages;		}				public function get bytesLoaded():Number		{			return _bytesLoaded;		}				public function get bytesTotal():Number		{			return _bytesTotal;		}				// takes a URLRequest object pointing to a file with XML data, downloads the data, and starts		// parsing it. the XML file is finished downloading when the PARSE_START event is sent.		// can also trigger IOErrorEvent and SecurityErrorEvent if there's a problem		public function load(address:URLRequest):void		{			_loader = new URLLoader();			// not bothering with a progress handler. the XML file should download pretty quickly, 			// so most of the overhead will be in connection setup. an indeterminate progress bar would 			// work just as well as one updated by a progress bar			_loader.addEventListener(Event.COMPLETE, _templateDataLoadedHandler);			// error event handlers are also used by the component loaders, and they mostly redispatch			// the event to TemplateLoader listeners			_loader.addEventListener(IOErrorEvent.IO_ERROR, _loadErrorHandler);			_loader.addEventListener(SecurityErrorEvent.SECURITY_ERROR, _loadSecurityHandler);			_loader.load(address);		}					// given an XML object representing a list of template sets, parses the data		// into an array of PosterTemplateSet objects and the associated children.		// returns the array, and sets parsedData		// if there's a problem anywhere along the way, throws a ParseError, which is		// allowed to propogate up to the caller		public function parse(input:XML):void		{			_parseDone = false;			// inform listeners the parsing is starting (might be useful for callers that			// use load() to start a parse)			dispatchEvent(new Event(TemplateLoader.PARSE_START));			// a ParseError exception can be thrown anywhere down the line, and while it's			// most important for the caller, it needs to be caught here so that any loaders			// that are in-progress can be halted			try			{				if ("posterList" in input)				{					// make sure there's data to work on					_checkRequired(input.posterList[0], ['posterTemplateSet']);					_parsedTemplates = new Array();					for each (var tmplSet:XML in input.posterList.posterTemplateSet)					{						_parsedTemplates.push(_parseTemplateSet(tmplSet));					}				}								if ("messageList" in input)				{					_checkRequired(input.messageList[0], ['messageGroup']);					_parsedMessages = new Array();					for each (var msgGroup:XML in input.messageList.messageGroup)					{						_parsedMessages.push(_parseMessageGroup(msgGroup));					}				}								// now, if both sets were parsed, give the messages to the PosterTemplateSet 				// objects so they can map textareas to MessageGroup objects				if (_parsedMessages != null && _parsedTemplates != null)				{					for each (var oneSet:PosterTemplateSet in _parsedTemplates)					{						oneSet.setMessages(_parsedMessages);					}				}			}			catch (e:ParseError)			{				_cancelLoaders();  // error stops any current loads				throw e;           // rethrow exception so caller can handle it			}			_parseDone = true;			// inform listeners that parsing is finished, though that doesn't mean the entire load			// is necessarily finished, as images and fonts might still be downloading			dispatchEvent(new Event(TemplateLoader.PARSE_COMPLETE));			// just in case, check to see if everything is finished. this is also called by the 			// various loaders, and it will dispatch the final complete event			_checkForComplete();		}				// END PUBLIC FUNCTIONS		// 		// everything past this point are internal functions used for parsing and loading,		// along with event handlers and some utility functions		//////////////////////////						//////////////////////////		// PARSING/LOADING METHODS		// 				// called by parse() for each posterTemplateSet tag in the XML. in turn, calls _parseTemplate		// on each posterTemplate contained in the set		private function _parseTemplateSet(setData:XML):PosterTemplateSet		{			_checkRequired(setData, ['@id', 'posterTemplate']);			var newSet:PosterTemplateSet = new PosterTemplateSet();			newSet.id = setData.@id;			_modelTmpl = null;   // clear this out because templates can't pull from a previous set			for each (var tmplData:XML in setData.posterTemplate)			{				newSet.templates.push(_parseTemplate(tmplData, newSet));			}			return newSet;		}				// called by _parseTemplateSet for each posterTemplate tag in the XML data. this is where most of the		// settings are defined, so this method does most of the work		private function _parseTemplate(tmplData:XML, parentSet:PosterTemplateSet):PosterTemplate		{			// templates can "inherit" image and textarea definitions from previous templates.			// the private property _modelTmpl is set to the last PosterTemplate that defined its own settings			// for image or textarea. if this template defines either of them, then this flag will get set to 			// true, and at the end this template will become the new model			var updateModel:Boolean = false;						// check for required fields. throws a ParseError if any are missing, and it's the job of the			// calling function to handle that error			_checkRequired(tmplData, ['width', 'height', 'resolution']);						// these 3 are required to even create the template object, so parse them first.			// throw an error if they're missing or if they're zero. similar to the above test, but this			// checks to make sure they're non-zero			var tmplWidth:Number = parseInt(tmplData.width);			var tmplHeight:Number = parseInt(tmplData.height);			var tmplResolution:Number = parseInt(tmplData.resolution);			if (!tmplWidth || !tmplHeight || !tmplResolution)			{				throw new ParseError("Every template must specify a non-zero poster height, width, and resolution");			}			var newTmpl:PosterTemplate = new PosterTemplate(tmplWidth, tmplHeight, tmplResolution, parentSet);						// calculate the scaling factors compared to the last template			var xScale:Number = 1;			var yScale:Number = 1;			var primaryScale:Number = 1;			var secondScale:Number = 1;			if (_modelTmpl)			{				xScale = newTmpl.inchesToPixels(newTmpl.width)  / _modelTmpl.inchesToPixels(_modelTmpl.width);				yScale = newTmpl.inchesToPixels(newTmpl.height) / _modelTmpl.inchesToPixels(_modelTmpl.height);				if (xScale > yScale)				{					primaryScale = xScale;					secondScale = yScale;				}				else				{					primaryScale = yScale;					secondScale = xScale;				}			}						// if label isn't specified, the PosterTemplate object will generate one in the form '11" x 17"'			if ('label' in tmplData)  newTmpl.label = tmplData.label;			// if backgroundColor is given, convert it into a format flash understands			if ('backgroundColor' in tmplData)			{				newTmpl.backgroundColor = _convertColor(tmplData.backgroundColor[0]);			}			else if (_modelTmpl != null)			{				newTmpl.backgroundColor = _modelTmpl.backgroundColor;			}						// see if a list of paper options is given. if not, see if it was given previously. throw an error			// if neither are true, since it's required			if ('paperOptions' in tmplData && 'paper' in tmplData.paperOptions)			{				for each (var paper:XML in tmplData.paperOptions.paper)				{					newTmpl.paperOptions.push(paper.toString());				}			}			else if (_modelTmpl && _modelTmpl.paperOptions.length)			{				newTmpl.paperOptions = _modelTmpl.paperOptions.slice();  // creates a duplicate of the array			}			else			{				throw new ParseError("At least one template in the set must have paperOptions");			}						// because each template can inherit images and textareas from the previous template in the set,			// start by cloning the previous template's lists (which could themselves be clones of the template			// before), then change them using any definitions in the current template, and finally check 			// the boundaries and adjust if the scaled images or textareas exceed the page size			//var cloneLast:Function = function (o:*):Object { return o.clone(cloned); };						// first, do the images			// if the image list is empty, this is probably the first template in the set, which means at least			// one image and most of its properties are required			if (!_modelTmpl || !_modelTmpl.images.length)			{				_checkRequired(tmplData, ['image']);				for each (var imgData:XML in tmplData.image)				{					_checkRequired(imgData, ['@id', 'x', 'y', 'width', 'height', 'preview']);					_checkRequired(imgData.preview[0], ['file']);				}			}			// otherwise, if images are inherited, copy and adjust them to account for the new page size			else			{				for each (var modelImg:PosterImage in _modelTmpl.images)				{					var img:PosterImage = modelImg.clone(newTmpl);					// first, calculate a bounding box that's scaled in the same way as the page					var boundX:Number = img.x * xScale;					var boundY:Number = img.y * yScale;					var boundWidth:Number = img.width * xScale;					var boundHeight:Number = img.height * yScale;					// next, calculate the size of the image after scaling proportionally					var newX:Number = boundX;					var newY:Number = boundY;					var newWidth:Number = img.width * primaryScale;					var newHeight:Number = img.height * primaryScale;					// now, see where the scaled image exceeds its bounding box and either crop or					// scale it more, depending on the crop instruction					if (newWidth > boundWidth || newHeight > boundHeight)					{						// if the image isn't supposed to be cropped, shrink it and center in the bounding box						if (img.crop == PosterImageCrop.NONE)						{							newWidth = img.width * secondScale;							newHeight = img.height * secondScale;							newX += (boundWidth - newWidth) / 2;    // center the image							newY += (boundHeight - newHeight) / 2;						}						// otherwise, make the dimensions equal the bounding box. the actual data will be changed						// according to the crop setting once the file is loaded						else						{							newWidth = boundWidth;							newHeight = boundHeight;						}					}					img.x = Math.round(newX);					img.y = Math.round(newY);					img.width = Math.round(newWidth);					img.height = Math.round(newHeight);					newTmpl.images.push(img);				}			}			// read the image definitions in the XML file to add new image objects, redefine existing ones,			// or remove ones that aren't used with this template			if ('image' in tmplData)			{				updateModel = true;				_parseImages(tmplData.image, newTmpl); 			}			// finally, make sure image data is loaded into the object			for each (var updateImg:PosterImage in newTmpl.images)			{				// img.previewFile has to be set by this point, but img.previewData probably isn't because the				// preview file probably hasn't finished downloading (or might not have even started). 				// _loadImage will load the image if needed, or if it's already loaded or in progress, will				// update img with the data once it's available				_loadImage(updateImg.previewFile, updateImg);			}						// now, do the textareas			if (!_modelTmpl || !_modelTmpl.textAreas.length)			{				_checkRequired(tmplData, ['textarea']);				for each (var txtData:XML in tmplData.textarea)				{					_checkRequired(txtData, ['@id', 'x', 'y', 'width', 'height', 'fontName', 'fontSize']);				}			}			else			{				//newTmpl.textAreas = _modelTmpl.textAreas.map(cloneLast);				for each (var modelArea:PosterTextArea in _modelTmpl.textAreas)				{					var area:PosterTextArea = modelArea.clone(newTmpl);					area.x = Math.round(area.x * xScale);					area.y = Math.round(area.y * yScale);					if (area.resize == PosterTextArea.MATCHPAGE)					{						area.width = Math.round(area.width * xScale);    // shrink sides of textarea by different						area.height = Math.round(area.height * yScale);  // amounts, to match the page					}					else					{						area.width = Math.round(area.width * primaryScale);    // default is to scale proportionally,						area.height = Math.round(area.height * primaryScale);  // using the primary ratio for both						// check to see if the textarea now exceeds the page, and if so, adjust it based on						// the oversides instructions						var overX:Number = area.x + area.width - newTmpl.inchesToPixels(newTmpl.width);						var overY:Number = area.y + area.height - newTmpl.inchesToPixels(newTmpl.height);						if (overX > 0 || overY > 0)						{							overX = (overX < 0) ? 0 : Math.floor(overX);							overY = (overY < 0) ? 0 : Math.floor(overY);							if (area.oversides == PosterTextArea.OVER_SHIFT)							{								area.x -= overX;   // move the textarea until it fits on the page								area.y -= overY;							}							else							{								area.width  -= overX;  // default is to cut off the textarea at								area.height -= overY;  // the page boundary							}						}					}					area.fontSize    = Math.floor(area.fontSize    * primaryScale);					area.fontMinSize = Math.floor(area.fontMinSize * primaryScale);					if (area.tracking)  area.tracking = Math.floor(area.tracking * primaryScale);					if (area.leading)   area.leading  = Math.floor(area.leading  * primaryScale);					newTmpl.textAreas.push(area);				}			}			// read the XML definitions for textarea to define new areas, redefine existing ones, or 			// remove ones not used 			if ('textarea' in tmplData)			{				updateModel = true;				_parseTextAreas(tmplData.textarea, newTmpl);			}			// finally, make sure Font objects are loaded into textareas			for each (var updateTxt:PosterTextArea in newTmpl.textAreas)			{				// txt.fontName will be set at this point, either to the same value as the model template or to				// a new value that was just defined. either way, txt.font nows needs to be filld with the Font				// object representing that typeface. _loadFont() will take care of filling it in, either by 				// doing it immediately if it's already loaded, or by downloading the file and adding the font				// to all the PosterTextArea objects that need it				_loadFont(updateTxt.fontName, updateTxt);				// if fontMinSize hasn't been defined, set it to the default				if (isNaN(updateTxt.fontMinSize))  updateTxt.fontMinSize = updateTxt.fontSize;			}						// if this template defined/redefined any images or textareas, make it the new model			if (updateModel)  _modelTmpl = newTmpl;						return newTmpl;		}				private function _parseImages(images:XMLList, tmpl:PosterTemplate):void		{			for each (var imgData:XML in images)			{				// make sure this has an id, which is required regardless of whether it's a redefine				if (!('@id' in imgData))  throw new ParseError("All image definitions must have an 'id'");								var prevPos:int = tmpl.getImageIndex(imgData.@id);				var img:PosterImage;				// if this is redefining a previous image, grab it. otherwise, create a new object to work on				if (prevPos < 0)				{					img = new PosterImage(tmpl);					img.id = imgData.@id;				}				else				{					img = tmpl.images[prevPos];				}								// if the only child property is the id, then it's actually deleting the image				if (imgData.children.length == 1)				{					tmpl.images.splice(prevPos, 1);  // remove the image from the list					img.destroy();   // delete references in it, since it's not needed				}				// otherwise, load up the object with data				else				{					if ('x'       in imgData)  img.x      = _convertMeasure(imgData.x, tmpl);					if ('y'       in imgData)  img.y      = _convertMeasure(imgData.y, tmpl);					if ('width'   in imgData)  img.width  = _convertMeasure(imgData.width, tmpl);					if ('height'  in imgData)  img.height = _convertMeasure(imgData.height, tmpl);					if ('crop'    in imgData)  img.crop   = imgData.crop;					if ('preview' in imgData && 'file' in imgData.preview)  img.previewFile = imgData.preview.file;					if ('original' in imgData)					{						_checkRequired(imgData.original[0], ['file', 'width', 'height']);						img.sourceFile = imgData.original.file;						img.sourceWidth = imgData.original.width;						img.sourceHeight = imgData.original.height;					}					// if this is a redefinition, the object is already updated. but if it's new,					// it needs to be added to the image list					if (prevPos < 0)  tmpl.images.push(img);				}			}		}				private function _parseTextAreas(areas:XMLList, tmpl:PosterTemplate):void		{			for each (var textData:XML in areas)			{				// make sure this has an id, which is required regardless of whether it's a redefine				if (!('@id' in textData))  throw new ParseError("All text area definitions must have an 'id'");								var prevPos:int = tmpl.getTextAreaIndex(textData.@id);				var txt:PosterTextArea;				if (prevPos < 0)				{					txt = new PosterTextArea(tmpl);					txt.id = textData.@id;				}				else				{					txt = tmpl.textAreas[prevPos];				}								// if the only child property is the id, it's deleting the textarea				if (textData.children.length == 1)				{					tmpl.textAreas.splice(prevPos, 1);  // remove the area from the list					txt.destroy();    // and get rid of it, since it's not needed anymore				}				else				{					if ('type'   in textData)  txt.type   = textData.type;					if ('label'  in textData)  txt.label  = textData.label;					if ('x'      in textData)  txt.x      = _convertMeasure(textData.x, tmpl);					if ('y'      in textData)  txt.y      = _convertMeasure(textData.y, tmpl);					if ('width'  in textData)  txt.width  = _convertMeasure(textData.width, tmpl);					if ('height' in textData)  txt.height = _convertMeasure(textData.height, tmpl);					if ('color'  in textData)  txt.color  = _convertColor(textData.color[0]);					if ('alpha'  in textData)  txt.alpha  = parseInt(textData.alpha) / 100;					if ('fontName'    in textData)  txt.fontName = textData.fontName;					if ('fontSize'    in textData)  txt.fontSize    = Math.floor(tmpl.pointsToPixels(parseInt(textData.fontSize)));					if ('fontMinSize' in textData)  txt.fontMinSize = Math.floor(tmpl.pointsToPixels(parseInt(textData.fontMinSize)));					if ('leading'     in textData)  txt.leading     = Math.floor(tmpl.pointsToPixels(parseInt(textData.leading)));					if ('tracking'    in textData)  txt.tracking    = Math.floor(tmpl.pointsToPixels(parseInt(textData.tracking)));					if ('align'       in textData)  txt.align       = textData.align;					if ('oversides'   in textData)  txt.oversides   = textData.oversides;					if ('resize'      in textData)  txt.resize      = textData.resize;					if ('stroke' in textData)					{						if (textData.stroke.children.length == 0)						{							txt.useStroke = false;						}						else						{							txt.useStroke = true;						}						if ('color'  in textData.stroke)  txt.strokeColor  = _convertColor(textData.stroke.color[0]);						if ('weight' in textData.stroke)  txt.strokeWeight = parseInt(textData.stroke.weight);					}					if ('dropShadow' in textData)					{						if (textData.dropShadow.children.length == 0)						{							txt.useShadow = false;						}						else						{							txt.useShadow = true;						}						if ('color'    in textData.dropShadow)  txt.shadowColor    = _convertColor(textData.dropShadow.color[0]);						if ('alpha'    in textData.dropShadow)  txt.shadowAlpha    = parseInt(textData.dropShadow.alpha) / 100;						if ('blur'     in textData.dropShadow)  txt.shadowBlur     = parseInt(textData.dropShadow.blur);						if ('angle'    in textData.dropShadow)  txt.shadowAngle    = parseInt(textData.dropShadow.angle);						if ('distance' in textData.dropShadow)  txt.shadowDistance = parseInt(textData.dropShadow.distance);					}					// if this is a redefinition, the object is already updated. but if it's new,					// it needs to be added to the textAreas list					if (prevPos < 0)  tmpl.textAreas.push(txt);				}			}		}				// loads the given font from the server and, once it's available, places the Font object into		// the given PosterTextArea's fontName property. also checks to see if the font is already loaded,		// in which case it skips loading and immediately fills in the property		private function _loadFont(fontName:String, target:PosterTextArea):void		{			// first check to see if any work is even needed			var fontObj:Font = _fontLoaded(fontName);			if (fontObj != null)			{				// font is already loaded and registered. stick it in the textarea and be done				target.font = fontObj;			}			else			{				// font isn't loaded yet, but see if it's in the process of being loaded.				// if so, attach this textarea to the existing loader so it'll get filled in once				// the font is ready				if (fontName in _fontsLoading && _fontsLoading[fontName] is ComponentLoader)				{					_fontsLoading[fontName].targets.push(target);				}				else				{					// have to load the font. create an instance of the custom loader, which stores some info					// about what's being loaded (most importantly, the target)					var loader:ComponentLoader = new ComponentLoader();					loader.compId = fontName;					loader.compType = ComponentLoader.FONT;					loader.targets.push(target);					// the progress and error handlers are shared with the image loader. the completion one is					// not though because the loaded data has to be processed differently.					loader.contentLoaderInfo.addEventListener(ProgressEvent.PROGRESS, _progressHandler);					loader.contentLoaderInfo.addEventListener(Event.COMPLETE, _fontLoadedHandler);					loader.contentLoaderInfo.addEventListener(IOErrorEvent.IO_ERROR, _loadErrorHandler);					loader.contentLoaderInfo.addEventListener(SecurityErrorEvent.SECURITY_ERROR, _loadSecurityHandler);					// the filename for each font is simply the font's name with all non-word characters stripped,					// plus the file extension (each font is embedded in a flash file)					var fontUrl:String = Config.fontBase + "/" + fontName.replace(/\W/g, "") + ".swf";										// loading the fonts works without creating a new LoaderContext, except the fonts 					// aren't properly registered in the global font list, making them inaccessible.					// so really, loading doesn't work without this					var context:LoaderContext = new LoaderContext(true, 						new ApplicationDomain(ApplicationDomain.currentDomain),						SecurityDomain.currentDomain					);					loader.load(new URLRequest(fontUrl), context);					_fontsLoading[fontName] = loader;					_loaderLookup[loader.contentLoaderInfo] = loader;				}			}		}				// loads the given image from the server and, once it's available, puts the data into the previewData		// property of the given PosterImage. also checks if the image is already loaded, or is in the process		// of being loaded, so it doesn't get downloaded twice.		private function _loadImage(imagePath:String, target:PosterImage)		{			// first, check if the image is already loaded			if (imagePath in _loadedImages)			{				_attachBitmapToPosterImage(_loadedImages[imagePath], target);			}			else			{				// image isn't loaded yet, but it might be downloading already. if so, attach this PosterImage				// to the existing loader so it'll get filled once the image is ready				if (imagePath in _imagesLoading && _imagesLoading[imagePath] is ComponentLoader)				{					_imagesLoading[imagePath].targets.push(target);				}				else				{					// have to load the image. create an instance of the custom loader, which stores					// some info about what's being loaded (most importantly, the target)					var loader:ComponentLoader = new ComponentLoader();					loader.compId = imagePath;					loader.compType = ComponentLoader.IMAGE;					loader.targets.push(target);					// the progress and error handlers are shared with the font loader. the completion one is					// not though because the loaded data has to be processed differently.					loader.contentLoaderInfo.addEventListener(ProgressEvent.PROGRESS, _progressHandler);					loader.contentLoaderInfo.addEventListener(Event.COMPLETE, _imageLoadedHandler);					loader.contentLoaderInfo.addEventListener(IOErrorEvent.IO_ERROR, _loadErrorHandler);					loader.contentLoaderInfo.addEventListener(SecurityErrorEvent.SECURITY_ERROR, _loadSecurityHandler);					// attach the imagePath to the imageBase to get the full URL					var imageUrl:String = Config.imageBase + "/" + imagePath;					loader.load(new URLRequest(imageUrl));					_imagesLoading[imagePath] = loader;					_loaderLookup[loader.contentLoaderInfo] = loader;				}			}		}				// takes a <messageGroup> XML section and turns it into a MessageGroup object with		// a series of Message objects as children. message loading is vastly simpler than template		// loading, so this code is very basic and doesn't need to call any other parse functions		private function _parseMessageGroup(groupData:XML):MessageGroup		{			_checkRequired(groupData, ['@type', 'message']);			var msgGroup:MessageGroup = new MessageGroup();			msgGroup.type = groupData.@type;			for each (var msg:XML in groupData.message)			{				msgGroup.messages.push(new Message(msg.toString(), MessageSource.SERVER));			}			return msgGroup;		}						//////////////////		// EVENT HANDLERS		// 				// used as the progress handler for both font and image loading. adds the individual load		// statistics to the total for the entire TemplateLoader instance. then dispatches a new		// progress event for the global values to whoever's listening for the TemplateLoader		private function _progressHandler(e:ProgressEvent):void		{			var loader:ComponentLoader = _loaderLookup[LoaderInfo(e.target)];			if (!loader.counted)			{				_bytesTotal += e.bytesTotal;				loader.counted = true;			}			_bytesLoaded += e.bytesLoaded - loader.lastByteCount;			loader.lastByteCount = e.bytesLoaded;			dispatchEvent(new ProgressEvent(ProgressEvent.PROGRESS, false, false, _bytesLoaded, _bytesTotal));		}				private function _loadErrorHandler(e:IOErrorEvent):void		{			// something failed to load, so redispatch the event to TemplateLoader listeners			dispatchEvent(e.clone());		}				private function _loadSecurityHandler(e:SecurityErrorEvent):void		{			// something failed to load because of security restrictions. redispatch the event			// for TemplateLoader listeners			dispatchEvent(e.clone());		}				private function _fontLoadedHandler(e:Event):void		{			var loader:ComponentLoader = e.target.loader;			// once the font is loaded, it adds itself to the global font list using registerFont(), so it			// should now be available. _fontLoaded will return a reference to it, or null if it's not			// available (which shouldn't happen, but just in case, it'll throw an error event)			var fontObj:Font = _fontLoaded(loader.compId)			if (fontObj != null)			{				// font is fully loaded, so remove it from the in-progress list				delete _fontsLoading[loader.compId];				delete _loaderLookup[loader.contentLoaderInfo];				// attach the font to all its targets				for each (var area:PosterTextArea in loader.targets)				{					area.font = fontObj;				}				_checkForComplete();  // see if the entire load process is done yet			}			else			{				// could happen if the font was packaged wrong and didn't call registerFont() to add				// itself to the global font list				dispatchEvent(new ErrorEvent(ErrorEvent.ERROR, false, false, "Font " + loader.compId + " loaded but failed to register"));			}		}				private function _imageLoadedHandler(e:Event):void		{			var loader:ComponentLoader = e.target.loader;    // get the loader, since it has information about the targets			var loadedData:Bitmap = Bitmap(e.target.content);  // get the loaded bitmap (though only the BitmapData is needed)			_loadedImages[loader.compId] = loadedData.bitmapData;			// image is fully loaded, so remove it from the in-progrss list			delete _imagesLoading[loader.compId];			delete _loaderLookup[loader.contentLoaderInfo];			// attach the image to all its targets			for each (var image:PosterImage in loader.targets)			{				_attachBitmapToPosterImage(loadedData.bitmapData, image);			}			_checkForComplete();  // see if the entire load process is done yet		}				// complete handler for the load() method. converts loaded data into XML and hands off to parse(),		// which takes care of saving the parsed data and dispatching progress events		private function _templateDataLoadedHandler(e:Event):void		{			var loader:URLLoader = URLLoader(e.target);			try			{				var loadedData:XML = new XML(loader.data);				this.parse(loadedData);			}			catch (err:Error)			{				// either the parsing of the actual XML data or the parsing of the XML object into				// template data failed. either way, report it with an error event.				// also clear the parsed data array out, in case it has some data in it. it's better to report no data				// than to report incomplete, possibly inconsistent data				_parsedTemplates = null;				_parsedMessages = null;				dispatchEvent(new ErrorEvent(ErrorEvent.ERROR, false, false, err.message + "\n" + err.getStackTrace()));			}		}						/////////////////////		// UTILITY FUNCTIONS		// 				// stops all current load operations. called when there's an error that halts parsing		private function _cancelLoaders():void		{			for each (var queue:Object in [_imagesLoading, _fontsLoading])			{				for each (var obj:* in queue)				{					obj.close();				}			}		}				// checks to see if the entire load has completed, meaning the parse has finished, all the		// images have finished loading, and all the fonts have finished loading.		// if everything is finished, dispatch the complete event		private function _checkForComplete():void		{			if (_parseDone)  // definitely not done if the XML hasn't even been parsed			{				// once the XML is finished parsing, all of the loaders will have started, and as they finish				// they get removed from the queues. so until all the queues are empty, the load isn't done.				// to test for this, assume the load is done until something is found in either one of the queues.				// as soon as one loader is found, stop looking				var done:Boolean = true;				for each (var queue:Object in [_imagesLoading, _fontsLoading])				{					for each (var obj:* in queue)					{						// if this loop runs, something is still loading						done = false;						break;					}					if (!done)  break;  // don't check the second queue if something is found in the first				}				// nothing is loading, so go ahead and signal that the load is completely done				if (done)  dispatchEvent(new Event(Event.COMPLETE));			}		}				// looks through the list of embedded fonts that have been loaded for one with the given name.		// if found, returns the associated Font object. otherwise, returns null		private function _fontLoaded(fontName:String):Font		{			// loop through a list of all the embedded fonts that are currently available			for each (var oneFont:Font in Font.enumerateFonts(false))			{				if (oneFont.fontName == fontName)  return oneFont;  // found match			}			return null;  // no match		}				// takes BitmapData representing an image loaded from the server and places it into PosterImage, possibly cropping it to		// match the aspect ratio defined by the PosterImage object's width and height values.		private function _attachBitmapToPosterImage(loadedData:BitmapData, image:PosterImage):void		{			// calculate the ratio of width to height for both the preview image and the container.			// if they're different, the data needs to be cropped to fit			var loadedRatio = loadedData.width / loadedData.height;			var targetRatio = image.width / image.height;						var cropBox:Rectangle = new Rectangle();  // rectangle defining the area to keep			// if the preview image has the higher ratio, it's too wide			if (loadedRatio > targetRatio)			{				// reduce the width to have the same ratio as the target				cropBox.width = Math.floor(loadedData.height * targetRatio);				cropBox.height = loadedData.height;  // no change vertically				cropBox.y = 0;				// use the cropping instructions to decide what to remove				// if the anchor point is topleft, the pixels on the right side will be discarded				if (image.crop == PosterImageCrop.TOPLEFT)				{					cropBox.x = 0;				}				// if the anchor point is bottomright, pixels on the left side will be discarded				else if (image.crop == PosterImageCrop.BOTTOMRIGHT)				{					cropBox.x = loadedData.width - cropBox.width;				}				// default anchor point is the center, so equal number of pixels will be discarded from both sides				else				{					cropBox.x = Math.floor((loadedData.width - cropBox.width) / 2);				}			}			// if the preview image has the smaller ratio, it's too tall			else if (loadedRatio < targetRatio)			{				// reduce the height to have the same ratio as the target				cropBox.height = Math.floor(loadedData.width / targetRatio);				cropBox.width = loadedData.width;   // no change horizontally				cropBox.x = 0;				// if the anchor point is topleft, pixels at the bottom will be discarded				if (image.crop == PosterImageCrop.TOPLEFT)				{					cropBox.y = 0;				}				// if the anchor point is bottomright, pixels at the top will be discarded				else if (image.crop == PosterImageCrop.BOTTOMRIGHT)				{					cropBox.y = loadedData.height - cropBox.height;				}				// default anchor point is middle, so equal number of pixels will be discarded from both sides				else				{					cropBox.y = Math.floor((loadedData.height - cropBox.height) / 2);				}			}			// the ratios are the same, so the image doesn't need cropping			else			{				cropBox.width = loadedData.width;				cropBox.height = loadedData.height;				cropBox.x = 0;				cropBox.y = 0;			}			// the cropped image goes in a new BitmapData object, so the cropped pixels aren't lost			var newData:BitmapData = new BitmapData(cropBox.width, cropBox.height);			// copy data inside the crop box of the loaded image into the new object			newData.copyPixels(loadedData, cropBox, new Point(0, 0));			image.previewData = newData;  // place the data with the PosterImage		}				// takes an XML node and a list of properties that must be present as children. 		// if one is missing, throws a ParseError with a message stating which property was missing from the XML		private function _checkRequired(node:XML, required:Array):void		{			for each (var prop:String in required)			{				if (!node.hasOwnProperty(prop))				{					throw new ParseError("Field '" + prop + "' must be present under '" + node.name() + "'");				}			}		}					// takes a string representing a measurement with units and returns an equivalent measure in pixels.		// also takes a PosterTemplate object because the physical-to-pixels conversion depends on the		// resolution. throws a ParseError if the string can't be converted		private function _convertMeasure(pos:String, tmpl:PosterTemplate):Number		{			var extract:RegExp = /([0-9.]+)\s*(\w{2})?\s*$/;			var parts:Object = extract.exec(pos);			if (parts == null)  throw new ParseError("Can't parse measurement: " + pos);						var measure:Number = parseFloat(parts[1]);  // first parenthetical group, the number			var units:String = parts[2];           // second group, the units						var converted:Number;			if (!units)  converted = measure;   // pixels is the default measure			else if (units == Units.INCHES)  converted = tmpl.inchesToPixels(measure);			else if (units == Units.POINTS)  converted = tmpl.pointsToPixels(measure);			else if (units == Units.PIXELS)  converted = measure;			else throw new ParseError("Unknown measurement units: " + units);						return converted;		}				// takes an XML node with tags of red, green, blue, each from 0 to 255, and returns the equivalent		// color as an unsigned integer		private function _convertColor(inColor:XML):uint		{			var newColor:uint = 0x00000000;  // start with a clear value			var red:uint = parseInt(inColor.red);			var green:uint = parseInt(inColor.green);			var blue:uint = parseInt(inColor.blue);			// bitshift the colors into place, making sure to set alpha to 1			//newColor = (0xFF << 24) | (red << 16) | (green << 8) | (blue)			newColor = (red << 16) | (green << 8) | (blue)			return newColor;		}	}}import flash.display.Loader;class ComponentLoader extends Loader{	public static const FONT:String  = "font";	public static const IMAGE:String = "image";		public var compId:String;	public var compType:String;	public var counted:Boolean;	public var targets:Array;	public var lastByteCount:Number;		public function ComponentLoader():void	{		targets = new Array();		counted = false;		lastByteCount = 0;		super();	}}